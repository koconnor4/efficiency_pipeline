

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>efficiency_pipeline.lco_fakeSNpipeline &mdash; efficiency_pipeline 0.0.1 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/gallery-binder.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/gallery-dataframe.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link href="../../_static/style.css" rel="stylesheet" type="text/css">

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home" alt="Documentation Home"> efficiency_pipeline
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html#using-your-own-data">Using Your Own Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html#effective-point-spread-function">Effective Point Spread Function</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../examples/plot_package.html">Basic Functionality</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributors.html">Primary Contributors</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">efficiency_pipeline</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>efficiency_pipeline.lco_fakeSNpipeline</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for efficiency_pipeline.lco_fakeSNpipeline</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">optparse</span> <span class="kn">import</span> <span class="n">OptionParser</span>
<span class="n">parser</span> <span class="o">=</span> <span class="n">OptionParser</span><span class="p">()</span>
<span class="p">(</span><span class="n">options</span><span class="p">,</span><span class="n">args</span><span class="p">)</span><span class="o">=</span><span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>

<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">matplotlib</span>
<span class="kn">from</span> <span class="nn">matplotlib.patches</span> <span class="kn">import</span> <span class="n">Circle</span>
<span class="kn">from</span> <span class="nn">matplotlib.colors</span> <span class="kn">import</span> <span class="n">BoundaryNorm</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">collections</span> 
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">curve_fit</span>

<span class="kn">import</span> <span class="nn">astropy</span>
<span class="kn">from</span> <span class="nn">astropy.io</span> <span class="kn">import</span> <span class="n">ascii</span><span class="p">,</span><span class="n">fits</span>
<span class="kn">from</span> <span class="nn">astropy.table</span> <span class="kn">import</span> <span class="n">vstack</span><span class="p">,</span><span class="n">Table</span><span class="p">,</span><span class="n">Column</span><span class="p">,</span><span class="n">Row</span><span class="p">,</span><span class="n">setdiff</span><span class="p">,</span><span class="n">join</span>
<span class="kn">from</span> <span class="nn">astropy.coordinates</span> <span class="kn">import</span> <span class="n">SkyCoord</span>
<span class="kn">import</span> <span class="nn">astropy.units</span> <span class="k">as</span> <span class="nn">u</span>
<span class="kn">from</span> <span class="nn">astropy.units</span> <span class="kn">import</span> <span class="n">Quantity</span>
<span class="kn">from</span> <span class="nn">astroquery.gaia</span> <span class="kn">import</span> <span class="n">Gaia</span>
<span class="kn">from</span> <span class="nn">astropy.convolution</span> <span class="kn">import</span> <span class="n">Gaussian2DKernel</span>
<span class="kn">from</span> <span class="nn">astropy.visualization</span> <span class="kn">import</span> <span class="n">ZScaleInterval</span><span class="p">,</span><span class="n">simple_norm</span>
<span class="n">zscale</span> <span class="o">=</span> <span class="n">ZScaleInterval</span><span class="p">()</span>
<span class="kn">from</span> <span class="nn">astropy.nddata</span> <span class="kn">import</span> <span class="n">Cutout2D</span><span class="p">,</span><span class="n">NDData</span>
<span class="kn">from</span> <span class="nn">astropy.stats</span> <span class="kn">import</span> <span class="n">sigma_clipped_stats</span><span class="p">,</span><span class="n">gaussian_fwhm_to_sigma</span><span class="p">,</span><span class="n">gaussian_sigma_to_fwhm</span>
<span class="kn">from</span> <span class="nn">astropy.wcs</span> <span class="kn">import</span> <span class="n">WCS</span>
<span class="kn">from</span> <span class="nn">astropy.wcs.utils</span> <span class="kn">import</span> <span class="n">skycoord_to_pixel</span>

<span class="kn">import</span> <span class="nn">photutils</span>
<span class="kn">from</span> <span class="nn">photutils</span> <span class="kn">import</span> <span class="n">find_peaks</span>
<span class="kn">from</span> <span class="nn">photutils.psf</span> <span class="kn">import</span> <span class="n">extract_stars</span>
<span class="kn">from</span> <span class="nn">photutils</span> <span class="kn">import</span> <span class="n">EPSFBuilder</span>
<span class="kn">from</span> <span class="nn">photutils</span> <span class="kn">import</span> <span class="n">detect_threshold</span>
<span class="kn">from</span> <span class="nn">photutils</span> <span class="kn">import</span> <span class="n">detect_sources</span>
<span class="kn">from</span> <span class="nn">photutils</span> <span class="kn">import</span> <span class="n">deblend_sources</span>
<span class="kn">from</span> <span class="nn">photutils</span> <span class="kn">import</span> <span class="n">source_properties</span><span class="p">,</span> <span class="n">EllipticalAperture</span>
<span class="kn">from</span> <span class="nn">photutils</span> <span class="kn">import</span> <span class="n">BoundingBox</span>
<span class="kn">from</span> <span class="nn">photutils</span> <span class="kn">import</span> <span class="n">Background2D</span><span class="p">,</span> <span class="n">MedianBackground</span>

<span class="kn">from</span> <span class="nn">.lco_figures</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c1"># Suppress warnings. Relevant for astroquery. Comment this out if you wish to see the warning messages</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="get_data"><a class="viewcode-back" href="../../api.html#efficiency_pipeline.lco_fakeSNpipeline.get_data">[docs]</a><span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    helper function that gets you a dictionary that uses filenames as keys to fits </span>
<span class="sd">    assumes images tucked in dirs like dia_out, dia_trim, source_im</span>
<span class="sd">    path argument should be string to where you are working</span>
<span class="sd">    if images not tucked in the dirs ... can uncomment these</span>
<span class="sd">    ims=glob.glob(&#39;*fits&#39;)</span>
<span class="sd">    for i in range(len(ims)):</span>
<span class="sd">        filename = ims[i].split(&#39;/&#39;)[-1]</span>
<span class="sd">        my_data[filename] = fits.open(ims[i])[0]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">my_data</span> <span class="o">=</span> <span class="p">{}</span> 
    <span class="c1"># this source im is a dir that you should make for each field with the image you want to use</span>
    <span class="c1"># ie will be the one that psf measured on and planting into</span>
    <span class="n">SOURCE_IM</span><span class="o">=</span><span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span><span class="s1">&#39;source_im/*fits&#39;</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">SOURCE_IM</span><span class="p">)):</span>
        <span class="n">filename</span><span class="o">=</span><span class="n">SOURCE_IM</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">my_data</span><span class="p">[</span><span class="n">filename</span><span class="p">]</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">SOURCE_IM</span><span class="p">[</span><span class="n">i</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">DIA_OUT</span><span class="o">=</span><span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span><span class="s1">&#39;dia_out/*&#39;</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">DIA_OUT</span><span class="p">)):</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">DIA_OUT</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">my_data</span><span class="p">[</span><span class="n">filename</span><span class="p">]</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">DIA_OUT</span><span class="p">[</span><span class="n">i</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">DIA_TRIM</span><span class="o">=</span><span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span><span class="s1">&#39;dia_trim/*&#39;</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">DIA_TRIM</span><span class="p">)):</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">DIA_TRIM</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">my_data</span><span class="p">[</span><span class="n">filename</span><span class="p">]</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">DIA_TRIM</span><span class="p">[</span><span class="n">i</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1">#print(my_data)</span>
    <span class="k">return</span> <span class="n">my_data</span></div>

<div class="viewcode-block" id="gaia_results"><a class="viewcode-back" href="../../api.html#efficiency_pipeline.lco_fakeSNpipeline.gaia_results">[docs]</a><span class="k">def</span> <span class="nf">gaia_results</span><span class="p">(</span><span class="n">image</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    epsf helper function uses Gaia query to get stars in image</span>
<span class="sd">    image argument is the LCO fits file  </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># image wcs and frame, for conversions pixels/skycoord</span>
    <span class="n">wcs</span><span class="p">,</span><span class="n">frame</span><span class="o">=</span><span class="n">WCS</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">header</span><span class="p">),</span><span class="n">image</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;RADESYS&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="c1"># coord of strong lensing galaxy</span>
    <span class="n">ra</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;CAT-RA&#39;</span><span class="p">]</span>
    <span class="n">dec</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;CAT-DEC&#39;</span><span class="p">]</span>
    <span class="n">coord</span> <span class="o">=</span> <span class="n">SkyCoord</span><span class="p">(</span><span class="n">ra</span><span class="p">,</span><span class="n">dec</span><span class="p">,</span><span class="n">unit</span><span class="o">=</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">hourangle</span><span class="p">,</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">))</span>

    <span class="c1"># the pixscale is same along x&amp;y and rotated to default (N up, E left) cdi_j ~ delta_ij</span>
    <span class="n">cdi_i</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;CD1_1&#39;</span><span class="p">]</span> <span class="c1"># deg/pixel</span>
    <span class="n">naxis</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;NAXIS1&#39;</span><span class="p">]</span> <span class="c1"># naxis1=naxis2</span>
    <span class="n">radius</span> <span class="o">=</span> <span class="mi">3600</span><span class="o">*</span><span class="n">cdi_i</span><span class="o">*</span><span class="n">naxis</span><span class="o">/</span><span class="mi">2</span> <span class="c1"># approx 800 arcsec entire image</span>
    <span class="n">radius</span><span class="o">*=.</span><span class="mi">75</span> <span class="c1"># do 3/4 of that</span>
    <span class="c1"># do the search</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">Gaia</span><span class="o">.</span><span class="n">query_object_async</span><span class="p">(</span><span class="n">coordinate</span><span class="o">=</span><span class="n">coord</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="n">radius</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">arcsec</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">,</span><span class="n">image</span></div>

<div class="viewcode-block" id="stars"><a class="viewcode-back" href="../../api.html#efficiency_pipeline.lco_fakeSNpipeline.stars">[docs]</a><span class="k">def</span> <span class="nf">stars</span><span class="p">(</span><span class="n">results</span><span class="p">,</span><span class="n">Nbrightest</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    epsf helper function extracts good stars from image and turns them into photutil epsf star objects</span>
<span class="sd">    good ~ well measured isolated stars:</span>
<span class="sd">    bbox of 25 pixels is used for extraction, any overlapping stars are removed</span>
<span class="sd">    gaia rp s/n &lt; 100 removed</span>
<span class="sd">    any stars with flux value &gt; saturation or non-lin of image are removed </span>
<span class="sd">    results argument is the gaia_results</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># stars are extracted from image to be ready for use in determine ePSF</span>
    <span class="c1"># note ref.fits doesn&#39;t have saturate and maxlin available the image should be just one of the trims</span>

    <span class="c1"># unpack gaia_results into the gaia catalog and image</span>
    <span class="n">r</span><span class="p">,</span><span class="n">image</span> <span class="o">=</span> <span class="n">results</span>
    <span class="c1"># need to give the results a column name x and y (pixel locations on image) for extract stars fcn which am going to apply</span>
    <span class="n">wcs</span><span class="p">,</span><span class="n">frame</span><span class="o">=</span><span class="n">WCS</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">header</span><span class="p">),</span><span class="n">image</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;RADESYS&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="n">positions</span><span class="p">,</span><span class="n">pixels</span><span class="o">=</span><span class="p">[],[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)):</span>
        <span class="n">position</span><span class="o">=</span><span class="n">SkyCoord</span><span class="p">(</span><span class="n">ra</span><span class="o">=</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;ra&#39;</span><span class="p">],</span><span class="n">dec</span><span class="o">=</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;dec&#39;</span><span class="p">],</span><span class="n">unit</span><span class="o">=</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">,</span><span class="n">frame</span><span class="o">=</span><span class="n">frame</span><span class="p">)</span>
        <span class="n">positions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">position</span><span class="p">)</span>
        <span class="n">pixel</span><span class="o">=</span><span class="n">skycoord_to_pixel</span><span class="p">(</span><span class="n">position</span><span class="p">,</span><span class="n">wcs</span><span class="p">)</span>
        <span class="n">pixels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pixel</span><span class="p">)</span>
    <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pixels</span><span class="p">],[</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pixels</span><span class="p">]</span>
    <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="n">Column</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="n">Column</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">r</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
    <span class="n">r</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;there are </span><span class="si">{}</span><span class="s1"> stars available within fov from gaia results queried&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)))</span>

    <span class="c1"># I am finding bboxes of the extractions I will do so I can remove any stars with overlaps </span>
    <span class="c1"># I want to extract all the stars wo overlaps before I start to remove any using photometry constraints to get &#39;good&#39; ones for psf</span>
    <span class="n">bboxes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">r</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span>
        <span class="n">size</span> <span class="o">=</span> <span class="mi">25</span>
        <span class="n">ixmin</span><span class="p">,</span><span class="n">ixmax</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">size</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">size</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">iymin</span><span class="p">,</span> <span class="n">iymax</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">size</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">size</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        
        <span class="n">bbox</span> <span class="o">=</span> <span class="n">BoundingBox</span><span class="p">(</span><span class="n">ixmin</span><span class="o">=</span><span class="n">ixmin</span><span class="p">,</span> <span class="n">ixmax</span><span class="o">=</span><span class="n">ixmax</span><span class="p">,</span> <span class="n">iymin</span><span class="o">=</span><span class="n">iymin</span><span class="p">,</span> <span class="n">iymax</span><span class="o">=</span><span class="n">iymax</span><span class="p">)</span>
        <span class="n">bboxes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bbox</span><span class="p">)</span>
    <span class="n">bboxes</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">bboxes</span><span class="p">)</span>
    <span class="n">r</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">bboxes</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;bbox&#39;</span><span class="p">)</span>
    <span class="c1"># using the bbox of each star from results to determine intersections, dont want confusion of multi-stars for ePSF</span>
    <span class="n">intersections</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">obj1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bboxes</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">bboxes</span><span class="p">)):</span>
            <span class="n">obj2</span> <span class="o">=</span> <span class="n">bboxes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">obj1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">obj2</span><span class="p">):</span>
                <span class="c1">#print(obj1,obj2)</span>
                <span class="c1"># these are the ones to remove </span>
                <span class="n">intersections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj1</span><span class="p">)</span> 
                <span class="n">intersections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj2</span><span class="p">)</span>
    <span class="c1"># use the intersections found to remove stars</span>
    <span class="n">j</span><span class="o">=</span><span class="mi">0</span>
    <span class="n">rows</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">r</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="s1">&#39;bbox&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">intersections</span><span class="p">:</span>
            <span class="c1">#tmp.remove(i)</span>
            <span class="n">row</span><span class="o">=</span><span class="n">j</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
        <span class="n">j</span><span class="o">+=</span><span class="mi">1</span>
    <span class="n">r</span><span class="o">.</span><span class="n">remove_rows</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> stars, after removing intersections&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)))</span>

    <span class="c1"># I am going to extract stars with strong signal in rp filter (the one lco is looking in)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="s1">&#39;phot_rp_mean_flux_over_error&#39;</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">100</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;restricting extractions to stars w rp flux/error &gt; 100 we have </span><span class="si">{}</span><span class="s1"> to consider&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)))</span>

    <span class="c1"># sort by the strongest signal/noise in r&#39; filter</span>
    <span class="c1"># r.sort(&#39;phot_rp_mean_flux_over_error&#39;)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    # don&#39;t think it will be necessary to limit to some N stars, might as well take all that will give good data for building psf</span>
<span class="sd">    if Nbrightest == None:</span>
<span class="sd">        Nbrightest = len(r)</span>
<span class="sd">    brightest_results = r[:Nbrightest]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">data</span>
    <span class="n">hdr</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">header</span>
    <span class="c1"># the header has L1 bkg values; should be the same as sigma clipped stats </span>
    <span class="n">L1mean</span><span class="p">,</span><span class="n">L1med</span><span class="p">,</span><span class="n">L1sigma</span><span class="p">,</span><span class="n">L1fwhm</span> <span class="o">=</span> <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;L1MEAN&#39;</span><span class="p">],</span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;L1MEDIAN&#39;</span><span class="p">],</span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;L1SIGMA&#39;</span><span class="p">],</span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;L1FWHM&#39;</span><span class="p">]</span> <span class="c1"># counts, fwhm in arcsec </span>
    <span class="n">mean_val</span><span class="p">,</span> <span class="n">median_val</span><span class="p">,</span> <span class="n">std_val</span> <span class="o">=</span> <span class="n">sigma_clipped_stats</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">2.</span><span class="p">)</span>  
    <span class="n">WMSSKYBR</span> <span class="o">=</span> <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;WMSSKYBR&#39;</span><span class="p">]</span> <span class="c1"># mag/arcsec^2 of sky bkg measured</span>
    <span class="c1"># AGGMAG the guide star magnitude header value would be simpler but it is given as unknown, ra/dec are provided for it though</span>
    <span class="c1"># grab some other useful header values now</span>
    <span class="n">pixscale</span><span class="p">,</span><span class="n">saturate</span><span class="p">,</span><span class="n">maxlin</span> <span class="o">=</span> <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;PIXSCALE&#39;</span><span class="p">],</span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;SATURATE&#39;</span><span class="p">],</span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;MAXLIN&#39;</span><span class="p">]</span> <span class="c1"># arcsec/pixel, counts for saturation and non-linearity levels</span>
    
    <span class="c1"># need bkg subtracted to extract stars, want to build ePSF using just star brightness </span>
    <span class="n">data</span> <span class="o">-=</span> <span class="n">median_val</span> <span class="c1"># L1med</span>
    <span class="n">nddata</span> <span class="o">=</span> <span class="n">NDData</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
    <span class="n">stars</span> <span class="o">=</span> <span class="n">extract_stars</span><span class="p">(</span><span class="n">nddata</span><span class="p">,</span><span class="n">catalogs</span><span class="o">=</span><span class="n">r</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>
    <span class="c1"># using the bbox of each star from results to determine intersections, dont want confusion of multi-stars for ePSF</span>
    <span class="c1"># this was done with all stars not just those extracted, this is an optional sanity check but don&#39;t need it</span>
    <span class="n">intersections</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">obj1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">stars</span><span class="o">.</span><span class="n">bbox</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">stars</span><span class="o">.</span><span class="n">bbox</span><span class="p">)):</span>
            <span class="n">obj2</span> <span class="o">=</span> <span class="n">stars</span><span class="o">.</span><span class="n">bbox</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">obj1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">obj2</span><span class="p">):</span>
                <span class="c1">#print(obj1,obj2)</span>
                <span class="c1"># these are the ones to remove </span>
                <span class="n">intersections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj1</span><span class="p">)</span> 
                <span class="n">intersections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj2</span><span class="p">)</span>
    <span class="c1"># use the intersections found to remove stars</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">stars</span><span class="p">]</span> <span class="c1"># get a list of stars rather than single photutils obj with all of them </span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tmp</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">bbox</span> <span class="ow">in</span> <span class="n">intersections</span><span class="p">:</span>
            <span class="n">tmp</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="c1">#print(&#39;{} stars, after removing intersections&#39;.format(len(tmp)))</span>
    

    <span class="c1"># note ref.fits doesn&#39;t have saturate and maxlin available the image should be just one of the trims</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tmp</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">saturate</span><span class="p">:</span>
            <span class="n">tmp</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">maxlin</span><span class="p">:</span>
            <span class="n">tmp</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;removed stars above saturation or non-linearity level ~ </span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="s1"> ADU; now have </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">saturate</span><span class="p">,</span><span class="n">maxlin</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">tmp</span><span class="p">)))</span>
    <span class="n">good_stars</span> <span class="o">=</span> <span class="n">photutils</span><span class="o">.</span><span class="n">psf</span><span class="o">.</span><span class="n">EPSFStars</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
    
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    # you should look at the images to make sure these are good stars</span>
<span class="sd">    nrows = 4</span>
<span class="sd">    ncols = 4</span>
<span class="sd">    fig, ax = plt.subplots(nrows=nrows, ncols=ncols, figsize=(20, 20),</span>
<span class="sd">                            squeeze=True)</span>
<span class="sd">    ax = ax.ravel()</span>
<span class="sd">    for i in range(len(brightest_results)):</span>
<span class="sd">        norm = simple_norm(stars[i], &#39;log&#39;, percent=99.)</span>
<span class="sd">        ax[i].imshow(stars[i], norm=norm, origin=&#39;lower&#39;, cmap=&#39;viridis&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#return stars</span>
    <span class="k">return</span> <span class="n">good_stars</span><span class="p">,</span><span class="n">image</span></div>

<div class="viewcode-block" id="ePSF"><a class="viewcode-back" href="../../api.html#efficiency_pipeline.lco_fakeSNpipeline.ePSF">[docs]</a><span class="k">def</span> <span class="nf">ePSF</span><span class="p">(</span><span class="n">stars</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;psf.fits&#39;</span><span class="p">,</span><span class="n">oversampling</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    function that builds an effective point spread function using an image&#39;s stars using photutils</span>
<span class="sd">    the effective point spread function representing truth more carefully than a 2d gaussian  </span>
<span class="sd">    minimal oversampling 2 is default since LCO is already oversampling the PSFs:</span>
<span class="sd">    typical rp_fwhm ~ 2 arcsec and pixscale ~ 0.4 arcsec</span>
<span class="sd">    stars argument is stars helper fcn</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># using all the available Gaia results which are below non-linearity/saturation to build an effective PSF </span>

    <span class="c1"># unpack the stars results into the good_stars and image </span>
    <span class="n">good_stars</span><span class="p">,</span> <span class="n">image</span> <span class="o">=</span> <span class="n">stars</span>

    <span class="n">hdr</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">header</span>
    <span class="n">L1mean</span><span class="p">,</span><span class="n">L1med</span><span class="p">,</span><span class="n">L1sigma</span><span class="p">,</span><span class="n">L1fwhm</span> <span class="o">=</span> <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;L1MEAN&#39;</span><span class="p">],</span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;L1MEDIAN&#39;</span><span class="p">],</span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;L1SIGMA&#39;</span><span class="p">],</span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;L1FWHM&#39;</span><span class="p">]</span> <span class="c1"># counts, fwhm in arcsec </span>
    <span class="n">pixscale</span><span class="p">,</span><span class="n">saturate</span><span class="p">,</span><span class="n">maxlin</span> <span class="o">=</span> <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;PIXSCALE&#39;</span><span class="p">],</span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;SATURATE&#39;</span><span class="p">],</span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;MAXLIN&#39;</span><span class="p">]</span> <span class="c1"># arcsec/pixel, counts for saturation and non-linearity levels</span>

    <span class="c1"># oversampling chops pixels of each star up further to get better fit</span>
    <span class="c1"># this is okay since stacking multiple ...</span>
    <span class="c1"># however more oversampled the ePSF is, the more stars you need to get smooth result</span>
    <span class="c1"># LCO is already oversampling the PSFs, the fwhm ~ 2 arcsec while pixscale ~ 0.4 arcsec; should be able to get good ePSF measurement without any oversampling</span>
    <span class="c1"># ePSF basic x,y,sigma 3 param model should be easily obtained if consider that 3*pixscale &lt; fwhm</span>
    <span class="n">epsf_builder</span> <span class="o">=</span> <span class="n">EPSFBuilder</span><span class="p">(</span><span class="n">oversampling</span><span class="o">=</span><span class="n">oversampling</span><span class="p">,</span> <span class="n">maxiters</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                                <span class="n">progress_bar</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
    <span class="n">epsf</span><span class="p">,</span> <span class="n">fitted_stars</span> <span class="o">=</span> <span class="n">epsf_builder</span><span class="p">(</span><span class="n">good_stars</span><span class="p">)</span>  
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    # take a look at the ePSF image </span>
<span class="sd">    norm = simple_norm(epsf.data, &#39;log&#39;, percent=99.)</span>
<span class="sd">    plt.imshow(epsf.data, norm=norm, origin=&#39;lower&#39;, cmap=&#39;viridis&#39;)</span>
<span class="sd">    plt.colorbar()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#fits.writeto(name,epsf.data,hdr,overwrite=True)</span>
    <span class="c1">#         fits.writeto(plantname,image.data,hdr,overwrite=True)</span>

    <span class="k">return</span> <span class="n">epsf</span><span class="p">,</span> <span class="n">fitted_stars</span></div>
<span class="kn">from</span> <span class="nn">photutils.datasets</span> <span class="kn">import</span> <span class="n">make_gaussian_sources_image</span>

<div class="viewcode-block" id="gaussian2d"><a class="viewcode-back" href="../../api.html#efficiency_pipeline.lco_fakeSNpipeline.gaussian2d">[docs]</a><span class="k">def</span> <span class="nf">gaussian2d</span><span class="p">(</span><span class="n">epsf</span><span class="p">,</span><span class="n">hdr</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    function to fit 2d gaussian to epsf</span>
<span class="sd">    photutils fit 2d gaussian has 7 parameters (constant,amplitude,x_mean,y_mean,x_stddev,y_stddev,theta) </span>
<span class="sd">    epsf argument is the photutils epsf from epsf fcn</span>
<span class="sd">    hdr optional argument will compare the L1fwhm available in reduced image to the fit  </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># use photutils 2d gaussian fit on the epsf</span>
    <span class="n">gaussian</span> <span class="o">=</span> <span class="n">photutils</span><span class="o">.</span><span class="n">centroids</span><span class="o">.</span><span class="n">fit_2dgaussian</span><span class="p">(</span><span class="n">epsf</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;gaussian fit to epsf:&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">gaussian</span><span class="o">.</span><span class="n">param_names</span><span class="p">,</span><span class="n">gaussian</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>
    <span class="c1"># unpack the parameters of fit</span>
    <span class="n">constant</span><span class="p">,</span><span class="n">amplitude</span><span class="p">,</span><span class="n">x_mean</span><span class="p">,</span><span class="n">y_mean</span><span class="p">,</span><span class="n">x_stddev</span><span class="p">,</span><span class="n">y_stddev</span><span class="p">,</span><span class="n">theta</span><span class="o">=</span><span class="n">gaussian</span><span class="o">.</span><span class="n">parameters</span>
    
    <span class="c1"># going to print approx resolution determined by epsf (according to average of the fits along x,y)</span>
    <span class="c1"># we have some rough idea of what the fwhm is predicted so is good check</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x_stddev</span><span class="p">)</span><span class="o">+</span><span class="nb">abs</span><span class="p">(</span><span class="n">y_stddev</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span> <span class="c1"># the average of x and y </span>
    <span class="n">sigma</span><span class="o">*=</span><span class="mi">1</span><span class="o">/</span><span class="n">epsf</span><span class="o">.</span><span class="n">oversampling</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># the model fit was to oversampled pixels need to correct for that for true image pix res</span>
    <span class="n">fwhm</span> <span class="o">=</span> <span class="n">gaussian_sigma_to_fwhm</span><span class="o">*</span><span class="n">sigma</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;gaussian fwhm ~ </span><span class="si">{}</span><span class="s1"> pixels (an avg of the fit sigma_x sigma_y w sigma_to_fwhm)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fwhm</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">hdr</span><span class="p">:</span>
        <span class="n">L1fwhm</span><span class="p">,</span><span class="n">pixscale</span> <span class="o">=</span> <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;L1fwhm&#39;</span><span class="p">],</span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;pixscale&#39;</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;frame L1fwhm stated in the hdr ~ </span><span class="si">{}</span><span class="s1"> arcsec, pixscale </span><span class="si">{}</span><span class="s1"> arcsec/pixel --&gt; fwhm ~ </span><span class="si">{}</span><span class="s1"> pixel&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">L1fwhm</span><span class="p">,</span><span class="n">pixscale</span><span class="p">,</span><span class="n">L1fwhm</span><span class="o">/</span><span class="n">pixscale</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;hopefully we are near consistent as sanity check&#39;</span><span class="p">)</span>
    
    <span class="c1"># here I take values of evaluated model fit along center of image</span>
    <span class="c1"># these might be useful to show</span>
    <span class="n">xctr_vals</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">y</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">epsf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">gaussval</span> <span class="o">=</span> <span class="n">gaussian</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">x_mean</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">constant</span><span class="p">,</span><span class="n">amplitude</span><span class="p">,</span><span class="n">x_mean</span><span class="p">,</span><span class="n">y_mean</span><span class="p">,</span><span class="n">x_stddev</span><span class="p">,</span><span class="n">y_stddev</span><span class="p">,</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">xctr_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gaussval</span><span class="p">)</span>
        <span class="n">y</span><span class="o">+=</span><span class="mi">1</span>
    <span class="n">yctr_vals</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">x</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">epsf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">gaussval</span> <span class="o">=</span> <span class="n">gaussian</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y_mean</span><span class="p">,</span><span class="n">constant</span><span class="p">,</span><span class="n">amplitude</span><span class="p">,</span><span class="n">x_mean</span><span class="p">,</span><span class="n">y_mean</span><span class="p">,</span><span class="n">x_stddev</span><span class="p">,</span><span class="n">y_stddev</span><span class="p">,</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">yctr_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gaussval</span><span class="p">)</span>
        <span class="n">x</span><span class="o">+=</span><span class="mi">1</span>
    
    <span class="c1"># here I am using the stddev in epsf to define levels n*sigma below the amplitude of the fit</span>
    <span class="c1"># is useful for contours</span>
    <span class="c1">#np.mean(psf.data),np.max(psf.data),np.min(psf.data),med=np.median(psf.data)</span>
    <span class="n">std</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">epsf</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="n">levels</span><span class="o">=</span><span class="p">[</span><span class="n">amplitude</span><span class="o">-</span><span class="mi">3</span><span class="o">*</span><span class="n">std</span><span class="p">,</span><span class="n">amplitude</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">std</span><span class="p">,</span><span class="n">amplitude</span><span class="o">-</span><span class="n">std</span><span class="p">]</span>
    <span class="c1">#plt.contour(psf.data,levels=levels)</span>
    
    <span class="n">table</span> <span class="o">=</span> <span class="n">Table</span><span class="p">()</span>
    <span class="n">table</span><span class="p">[</span><span class="s1">&#39;constant&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">constant</span><span class="p">]</span>
    <span class="n">table</span><span class="p">[</span><span class="s1">&#39;amplitude&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">amplitude</span><span class="p">]</span>
    <span class="n">table</span><span class="p">[</span><span class="s1">&#39;x_mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x_mean</span><span class="p">]</span>
    <span class="n">table</span><span class="p">[</span><span class="s1">&#39;y_mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">y_mean</span><span class="p">]</span>
    <span class="n">table</span><span class="p">[</span><span class="s1">&#39;x_stddev&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x_stddev</span><span class="p">]</span>
    <span class="n">table</span><span class="p">[</span><span class="s1">&#39;y_stddev&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">y_stddev</span><span class="p">]</span>
    <span class="n">table</span><span class="p">[</span><span class="s1">&#39;theta&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">theta</span><span class="p">]))</span>
    
    <span class="n">shape</span><span class="o">=</span><span class="n">epsf</span><span class="o">.</span><span class="n">shape</span>
    <span class="c1"># making numpy array of model values in shape of epsf</span>
    <span class="n">image1</span> <span class="o">=</span> <span class="n">make_gaussian_sources_image</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">table</span><span class="p">)</span>
    <span class="c1"># turning model array into epsf obj for easy manipulation with the epsf</span>
    <span class="n">img_epsf</span> <span class="o">=</span> <span class="n">photutils</span><span class="o">.</span><span class="n">psf</span><span class="o">.</span><span class="n">EPSFStar</span><span class="p">(</span><span class="n">image1</span><span class="o">.</span><span class="n">data</span><span class="p">,</span><span class="n">cutout_center</span><span class="o">=</span><span class="p">(</span><span class="n">x_mean</span><span class="p">,</span><span class="n">y_mean</span><span class="p">))</span>
    <span class="c1"># for example the residual of gaussian model with the epsf...</span>
    <span class="n">resid</span> <span class="o">=</span> <span class="n">img_epsf</span><span class="o">.</span><span class="n">compute_residual_image</span><span class="p">(</span><span class="n">epsf</span><span class="p">)</span>
    <span class="c1"># idk what&#39;s happening with compute_residual_image but it isn&#39;t straight-forward subtraction of img_epsf - epsf</span>
    <span class="c1"># some parameter about the scale for registered epsf is being used, where it assumes img_epsf is a star, I really just can use a straight sub of the gauss model fit - epsf</span>
    <span class="n">resid</span> <span class="o">=</span> <span class="n">img_epsf</span><span class="o">.</span><span class="n">data</span> <span class="o">-</span> <span class="n">epsf</span><span class="o">.</span><span class="n">data</span> 
    <span class="k">return</span> <span class="n">gaussian</span><span class="p">,</span><span class="n">levels</span><span class="p">,</span><span class="n">xctr_vals</span><span class="p">,</span><span class="n">yctr_vals</span><span class="p">,</span><span class="n">image1</span><span class="p">,</span><span class="n">img_epsf</span><span class="p">,</span><span class="n">resid</span>
    <span class="c1">#return image1</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    # we don&#39;t want noise for our planted psf or gaussian model, in general though could add like below</span>
<span class="sd">    image2 = image1 + make_noise_image(shape, distribution=&#39;gaussian&#39;,</span>
<span class="sd">                                   mean=5., stddev=5.)</span>
<span class="sd">    image3 = image1 + make_noise_image(shape, distribution=&#39;poisson&#39;,</span>
<span class="sd">                                   mean=5.)</span>
<span class="sd">    &quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="source_cat"><a class="viewcode-back" href="../../api.html#efficiency_pipeline.lco_fakeSNpipeline.source_cat">[docs]</a><span class="k">def</span> <span class="nf">source_cat</span><span class="p">(</span><span class="n">image</span><span class="p">,</span><span class="n">nsigma</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">kernel_size</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="n">npixels</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">deblend</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">contrast</span><span class="o">=.</span><span class="mi">001</span><span class="p">,</span><span class="n">targ_coord</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    function that gives catalog of detected objects in fits image with photometry based measurements </span>
<span class="sd">    arguments:</span>
<span class="sd">    image ~ the fits file that will be searched</span>
<span class="sd">    nsigma ~ what is considered &#39;detectable&#39; in photutils detect_threshold, which does sigma clipped stats to get image bkg</span>
<span class="sd">    kernel_size ~ pixel size of gaussian kernel convolved with data to smooth image objs </span>
<span class="sd">    npixels ~ number of pixels which must be connected above nsigma threshold (connectivity=8 along edges or corner)</span>
<span class="sd">    if very crowded...</span>
<span class="sd">    deblend will check detected objs for local peaks with contrast (percentage of obj total flux) &gt; .001</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># to be able to translate from ra/dec &lt;--&gt; pixels on image</span>
    <span class="n">wcs</span><span class="p">,</span><span class="n">frame</span> <span class="o">=</span> <span class="n">WCS</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">header</span><span class="p">),</span><span class="n">image</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;RADESYS&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="n">hdr</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">header</span>
    <span class="c1">#L1mean,L1med,L1sigma,L1fwhm = hdr[&#39;L1MEAN&#39;],hdr[&#39;L1MEDIAN&#39;],hdr[&#39;L1SIGMA&#39;],hdr[&#39;L1FWHM&#39;] # counts, fwhm in arcsec </span>
    <span class="c1">#pixscale,saturate,maxlin = hdr[&#39;PIXSCALE&#39;],hdr[&#39;SATURATE&#39;],hdr[&#39;MAXLIN&#39;] # arcsec/pixel, counts for saturation and non-linearity levels</span>

    <span class="c1"># detect threshold uses sigma clipped statistics to get bkg flux and set a threshold for detected sources as objs above nsigma*bkg</span>
    <span class="c1"># bkg also available in the hdr of file, either way is fine  </span>
    <span class="n">threshold</span> <span class="o">=</span> <span class="n">detect_threshold</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">nsigma</span><span class="o">=</span><span class="n">nsigma</span><span class="p">)</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="n">gaussian_fwhm_to_sigma</span>  <span class="c1"># FWHM = 3. pixels for kernel smoothing</span>
    <span class="c1"># optional ~ kernel smooths the image, using gaussian weighting with pixel size of 3</span>
    <span class="n">kernel</span> <span class="o">=</span> <span class="n">Gaussian2DKernel</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">x_size</span><span class="o">=</span><span class="n">kernel_size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y_size</span><span class="o">=</span><span class="n">kernel_size</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">kernel</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>
    <span class="c1"># make a segmentation map, id sources defined as n connected pixels above threshold (n*sigma + bkg)</span>
    <span class="n">segm</span> <span class="o">=</span> <span class="n">detect_sources</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                          <span class="n">threshold</span><span class="p">,</span> <span class="n">npixels</span><span class="o">=</span><span class="n">npixels</span><span class="p">,</span> <span class="n">filter_kernel</span><span class="o">=</span><span class="n">kernel</span><span class="p">)</span>
    <span class="c1"># deblend useful for very crowded image with many overlapping objects...</span>
    <span class="c1"># uses multi-level threshold and watershed segmentation to sep local peaks as ind obj</span>
    <span class="c1"># use the same number of pixels and filter as was used on original segmentation</span>
    <span class="c1"># contrast is fraction of source flux local pk has to be consider its own obj</span>
    <span class="k">if</span> <span class="n">deblend</span><span class="p">:</span>
        <span class="n">segm</span> <span class="o">=</span> <span class="n">deblend_sources</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> 
                                       <span class="n">segm</span><span class="p">,</span> <span class="n">npixels</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">filter_kernel</span><span class="o">=</span><span class="n">kernel</span><span class="p">,</span> 
                                       <span class="n">nlevels</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span><span class="n">contrast</span><span class="o">=</span><span class="n">contrast</span><span class="p">)</span>

    <span class="c1"># need bkg subtracted to do photometry using source properties</span>
    <span class="n">boxsize</span><span class="o">=</span><span class="mi">100</span>
    <span class="n">bkg</span> <span class="o">=</span> <span class="n">Background2D</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">data</span><span class="p">,</span><span class="n">boxsize</span><span class="p">)</span> <span class="c1"># sigma-clip stats for background est over image on boxsize, regions interpolated to give final map </span>
    <span class="n">data_bkgsub</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">data</span> <span class="o">-</span> <span class="n">bkg</span><span class="o">.</span><span class="n">background</span>
    <span class="n">cat</span> <span class="o">=</span> <span class="n">source_properties</span><span class="p">(</span><span class="n">data_bkgsub</span><span class="p">,</span> <span class="n">segm</span><span class="p">,</span><span class="n">background</span><span class="o">=</span><span class="n">bkg</span><span class="o">.</span><span class="n">background</span><span class="p">,</span>
                            <span class="n">error</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">filter_kernel</span><span class="o">=</span><span class="n">kernel</span><span class="p">)</span>
    
    <span class="c1"># going to id the target lensing galaxy from source catalog</span>
    <span class="c1"># since this is ideal detection location where strong lens could provide multi-im</span>
    <span class="c1"># this is going to be area where we will most want to plant and study </span>
    
    <span class="c1">#CAT-RA  = &#39;blah&#39;       / [HH:MM:SS.sss] Catalog RA of the object        </span>
    <span class="c1">#CAT-DEC = &#39;blah&#39;       / [sDD:MM:SS.ss] Catalog Dec of the object</span>
    <span class="k">if</span> <span class="n">targ_coord</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># the source images all have cat-ra cat-dec, will default grab target galaxy location from hdr</span>
        <span class="n">ra</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;CAT-RA&#39;</span><span class="p">]</span>
        <span class="n">dec</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;CAT-DEC&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># if using the ref to detect source objs the target stuff isn&#39;t in there will need to provide tuple taken from source hdr </span>
        <span class="n">ra</span><span class="p">,</span><span class="n">dec</span> <span class="o">=</span> <span class="n">targ_coord</span> <span class="c1"># unpack</span>

    <span class="n">lensing_gal</span> <span class="o">=</span> <span class="n">SkyCoord</span><span class="p">(</span><span class="n">ra</span><span class="p">,</span><span class="n">dec</span><span class="p">,</span><span class="n">unit</span><span class="o">=</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">hourangle</span><span class="p">,</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">))</span>
    <span class="n">pix_gal</span> <span class="o">=</span> <span class="n">astropy</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">skycoord_to_pixel</span><span class="p">(</span><span class="n">lensing_gal</span><span class="p">,</span><span class="n">wcs</span><span class="p">)</span>

    <span class="c1"># TODO all sources of error including poisson from sources</span>
    <span class="n">tbl</span> <span class="o">=</span> <span class="n">cat</span><span class="o">.</span><span class="n">to_table</span><span class="p">()</span>
    <span class="n">tbl</span><span class="p">[</span><span class="s1">&#39;xcentroid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">format</span> <span class="o">=</span> <span class="s1">&#39;.2f&#39;</span>  <span class="c1"># optional format</span>
    <span class="n">tbl</span><span class="p">[</span><span class="s1">&#39;ycentroid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">format</span> <span class="o">=</span> <span class="s1">&#39;.2f&#39;</span>
    <span class="n">tbl</span><span class="p">[</span><span class="s1">&#39;cxx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">format</span> <span class="o">=</span> <span class="s1">&#39;.2f&#39;</span>
    <span class="n">tbl</span><span class="p">[</span><span class="s1">&#39;cxy&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">format</span> <span class="o">=</span> <span class="s1">&#39;.2f&#39;</span>
    <span class="n">tbl</span><span class="p">[</span><span class="s1">&#39;cyy&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">format</span> <span class="o">=</span> <span class="s1">&#39;.2f&#39;</span>
    <span class="n">tbl</span><span class="p">[</span><span class="s1">&#39;gini&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">format</span> <span class="o">=</span> <span class="s1">&#39;.2f&#39;</span>

    <span class="c1"># going to add a column of surface brightness so we can plant into the obj shapes according to those</span>
    <span class="n">surf_brightnesses</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">tbl</span><span class="p">:</span>
        <span class="n">unit</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">obj</span><span class="p">[</span><span class="s1">&#39;area&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unit</span>
        <span class="n">surf_bright</span> <span class="o">=</span> <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;source_sum&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">obj</span><span class="p">[</span><span class="s1">&#39;area&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="c1"># flux/pix^2</span>
        <span class="n">surf_brightnesses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">surf_bright</span><span class="p">)</span> 
    <span class="n">surf_brightnesses</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">surf_brightnesses</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;surface_brightness&#39;</span><span class="p">,</span><span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">)</span>
    <span class="n">tbl</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">surf_brightnesses</span><span class="p">)</span>

    <span class="c1"># take a look at the brightest or most elliptical objs from phot on segm objs detected</span>
    <span class="n">tbl</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="s1">&#39;ellipticity&#39;</span><span class="p">)</span> <span class="c1">#</span>
    <span class="n">elliptical</span><span class="o">=</span><span class="n">tbl</span><span class="p">[</span><span class="o">-</span><span class="mi">10</span><span class="p">:]</span>
    <span class="c1">#tbl.sort(&#39;source_sum&#39;) (&#39;surface_brightness&#39;) </span>

    <span class="c1"># there is definitely a neater/cuter way to index table than this using loc to find obj of gal </span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">tbl</span><span class="p">[</span><span class="n">tbl</span><span class="p">[</span><span class="s1">&#39;xcentroid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">&gt;</span> <span class="n">pix_gal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">10</span><span class="p">]</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="n">tmp</span><span class="p">[</span><span class="s1">&#39;xcentroid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">pix_gal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">10</span><span class="p">]</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="n">tmp</span><span class="p">[</span><span class="s1">&#39;ycentroid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">&gt;</span> <span class="n">pix_gal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">10</span><span class="p">]</span>
    <span class="n">targ_obj</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="n">tmp</span><span class="p">[</span><span class="s1">&#39;ycentroid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">pix_gal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">10</span><span class="p">]</span> 
    <span class="n">targ_sb</span> <span class="o">=</span> <span class="n">targ_obj</span><span class="p">[</span><span class="s1">&#39;source_sum&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">targ_obj</span><span class="p">[</span><span class="s1">&#39;area&#39;</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">cat</span><span class="p">,</span><span class="n">image</span><span class="p">,</span><span class="n">threshold</span><span class="p">,</span><span class="n">segm</span><span class="p">,</span><span class="n">targ_obj</span></div>

<div class="viewcode-block" id="target"><a class="viewcode-back" href="../../api.html#efficiency_pipeline.lco_fakeSNpipeline.target">[docs]</a><span class="k">def</span> <span class="nf">target</span><span class="p">(</span><span class="n">image</span><span class="p">,</span><span class="n">targ_obj</span><span class="p">,</span><span class="n">ref</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">diff</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    helper function for the target detection efficiency</span>
<span class="sd">    gives cutouts on images (trim,ref,diff) around galaxy-galaxy strong lens</span>
<span class="sd">    checks source catalog to make sure it is one of image&#39;s detected objects otherwise will get properties from reference</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">targ_obj</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># the target isnt detected in image by my source_cat (photutils)...likely bad skymag bkg</span>
        <span class="c1"># going to use ref.fits to cut around the target and extract the parameters from these</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;the target obj wasnt detected in source image, using ref image to get the target photutil params&#39;</span><span class="p">)</span>
        <span class="c1">#ref = my_data[&#39;ref.fits&#39;]</span>
        <span class="n">wcs</span><span class="p">,</span><span class="n">frame</span> <span class="o">=</span> <span class="n">WCS</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">header</span><span class="p">),</span><span class="n">image</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;RADESYS&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="c1"># the target strong lensing galaxy position</span>
        <span class="n">ra</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;CAT-RA&#39;</span><span class="p">]</span>
        <span class="n">dec</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;CAT-DEC&#39;</span><span class="p">]</span>
        <span class="n">targ_coord</span> <span class="o">=</span> <span class="p">(</span><span class="n">ra</span><span class="p">,</span><span class="n">dec</span><span class="p">)</span>
        <span class="c1"># not cutting the ref on target to save computation time, get hdr error in source cat if do</span>
        <span class="c1">#coord = SkyCoord(ra,dec,unit=(u.hourangle,u.deg))        </span>
        <span class="c1">#pix=astropy.wcs.utils.skycoord_to_pixel(coord,wcs) # x,y pixel location</span>
        <span class="c1">#cut_ref = Cutout2D(ref.data,pix,25) # is 25 pixels big enough for any of the strong lens objects but small enough to avoid other objs?</span>
        <span class="c1"># photutils source properties to detect objs in image</span>
        <span class="c1">#cut_ref_catalog = source_cat(cut_ref)</span>
        <span class="c1">#cut_ref_cat,cut_ref_image,threshold,segm,targ_obj = source_catalog # unpacked to make a little clearer</span>
        <span class="n">ref_catalog</span> <span class="o">=</span> <span class="n">source_cat</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span><span class="n">targ_coord</span><span class="o">=</span><span class="n">targ_coord</span><span class="p">)</span>
        <span class="n">ref_cat</span><span class="p">,</span><span class="n">ref_image</span><span class="p">,</span><span class="n">threshold</span><span class="p">,</span><span class="n">segm</span><span class="p">,</span><span class="n">targ_obj</span> <span class="o">=</span> <span class="n">ref_catalog</span> <span class="c1"># unpacked to make a little clearer</span>
        <span class="c1"># take useful photutil params for strong lensing galaxy target </span>
        <span class="c1"># pixels and deg, sums ~ brightness in adu ~ for lco is straight counts (ie not yet rate isn&#39;t /exptime)</span>
        <span class="n">equivalent_radius</span> <span class="o">=</span> <span class="n">targ_obj</span><span class="p">[</span><span class="s1">&#39;equivalent_radius&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
        <span class="n">xy</span> <span class="o">=</span> <span class="p">(</span><span class="n">targ_obj</span><span class="p">[</span><span class="s1">&#39;xcentroid&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">,</span><span class="n">targ_obj</span><span class="p">[</span><span class="s1">&#39;ycentroid&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> 
        <span class="n">semimajor_axis</span><span class="p">,</span> <span class="n">semiminor_axis</span> <span class="o">=</span> <span class="n">targ_obj</span><span class="p">[</span><span class="s1">&#39;semimajor_axis_sigma&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">,</span><span class="n">targ_obj</span><span class="p">[</span><span class="s1">&#39;semiminor_axis_sigma&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
        <span class="n">orientation</span> <span class="o">=</span> <span class="n">targ_obj</span><span class="p">[</span><span class="s1">&#39;orientation&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> 
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># the source image detected the targ_obj so take useful values already available (no need to get ref involved)</span>
        <span class="c1"># pixels and deg, sums ~ brightness in adu ~ for lco is straight counts (ie not yet rate isn&#39;t /exptime)</span>
        <span class="n">equivalent_radius</span> <span class="o">=</span> <span class="n">targ_obj</span><span class="p">[</span><span class="s1">&#39;equivalent_radius&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
        <span class="n">xy</span> <span class="o">=</span> <span class="p">(</span><span class="n">targ_obj</span><span class="p">[</span><span class="s1">&#39;xcentroid&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">,</span><span class="n">targ_obj</span><span class="p">[</span><span class="s1">&#39;ycentroid&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> 
        <span class="n">semimajor_axis</span><span class="p">,</span> <span class="n">semiminor_axis</span> <span class="o">=</span> <span class="n">targ_obj</span><span class="p">[</span><span class="s1">&#39;semimajor_axis_sigma&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">,</span><span class="n">targ_obj</span><span class="p">[</span><span class="s1">&#39;semiminor_axis_sigma&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
        <span class="n">orientation</span> <span class="o">=</span> <span class="n">targ_obj</span><span class="p">[</span><span class="s1">&#39;orientation&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> 
    
    <span class="c1"># cut around the image on target</span>
    <span class="n">cut_targ</span> <span class="o">=</span> <span class="n">Cutout2D</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">data</span><span class="p">,</span><span class="n">xy</span><span class="p">,</span><span class="n">equivalent_radius</span><span class="o">*</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">cuts</span> <span class="o">=</span> <span class="p">[</span><span class="n">cut_targ</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">diff</span><span class="p">:</span>
        <span class="n">cut_diff</span> <span class="o">=</span> <span class="n">Cutout2D</span><span class="p">(</span><span class="n">diff</span><span class="o">.</span><span class="n">data</span><span class="p">,</span><span class="n">xy</span><span class="p">,</span><span class="n">equivalent_radius</span><span class="o">*</span><span class="mi">5</span><span class="p">)</span>
        <span class="n">cuts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cut_diff</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ref</span><span class="p">:</span>
        <span class="n">cut_ref</span> <span class="o">=</span> <span class="n">Cutout2D</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">data</span><span class="p">,</span><span class="n">xy</span><span class="p">,</span><span class="n">equivalent_radius</span><span class="o">*</span><span class="mi">5</span><span class="p">)</span>
        <span class="n">cuts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cut_ref</span><span class="p">)</span>

    <span class="c1"># now going to grab (cutouts/patches) of boxes on galaxy </span>
    <span class="n">cut_xy</span> <span class="o">=</span> <span class="n">cut_targ</span><span class="o">.</span><span class="n">center_cutout</span>
    <span class="n">shift_x</span> <span class="o">=</span> <span class="n">equivalent_radius</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">orientation</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">180</span><span class="p">)</span>
    <span class="n">shift_y</span> <span class="o">=</span> <span class="n">equivalent_radius</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">orientation</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">180</span><span class="p">)</span>

    <span class="c1"># lets do a box on the ctr with length=width=radius </span>
    <span class="c1"># the patch anchors on sw so shift the cut_xy </span>
    <span class="n">anchor_core</span> <span class="o">=</span> <span class="p">(</span><span class="n">cut_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">equivalent_radius</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">cut_xy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">equivalent_radius</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="c1"># the patch (show in figures)</span>
    <span class="n">box_core</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">patches</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">(</span><span class="n">anchor_core</span><span class="p">,</span><span class="n">equivalent_radius</span><span class="p">,</span><span class="n">equivalent_radius</span><span class="p">,</span><span class="n">fill</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="c1"># the cut (does sum for bkg)</span>
    <span class="n">xy_core</span> <span class="o">=</span> <span class="n">xy</span> <span class="c1"># the center of galaxy in image</span>
    <span class="n">cut_core</span> <span class="o">=</span> <span class="n">Cutout2D</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">data</span><span class="p">,</span><span class="n">xy_core</span><span class="p">,</span><span class="n">equivalent_radius</span><span class="p">)</span>
    
    <span class="c1"># shift box an equivalent radius along orientation from photutils creating next box </span>
    <span class="c1"># assuming orientation ccw from x (east)</span>
    <span class="c1"># yes the boxes will overlap slightly unless orientation fully along x or y</span>
    <span class="n">shift_x</span> <span class="o">=</span> <span class="n">equivalent_radius</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">orientation</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">180</span><span class="p">)</span>
    <span class="n">shift_y</span> <span class="o">=</span> <span class="n">equivalent_radius</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">orientation</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">180</span><span class="p">)</span>
    <span class="n">anchor_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">anchor_core</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">shift_x</span><span class="p">,</span><span class="n">anchor_core</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">shift_y</span><span class="p">)</span>
    <span class="n">box_1</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">patches</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">(</span><span class="n">anchor_1</span><span class="p">,</span><span class="n">equivalent_radius</span><span class="p">,</span><span class="n">equivalent_radius</span><span class="p">,</span><span class="n">fill</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="c1"># the cut (does sum for bkg)</span>
    <span class="n">xy_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">shift_y</span><span class="p">,</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">shift_y</span><span class="p">)</span> 
    <span class="n">cut_1</span> <span class="o">=</span> <span class="n">Cutout2D</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">data</span><span class="p">,</span><span class="n">xy_1</span><span class="p">,</span><span class="n">equivalent_radius</span><span class="p">)</span>
    
    <span class="c1"># similar shift one more time </span>
    <span class="n">anchor_2</span> <span class="o">=</span> <span class="p">(</span><span class="n">anchor_core</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">shift_x</span><span class="p">,</span><span class="n">anchor_core</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">shift_y</span><span class="p">)</span>
    <span class="n">box_2</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">patches</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">(</span><span class="n">anchor_2</span><span class="p">,</span><span class="n">equivalent_radius</span><span class="p">,</span><span class="n">equivalent_radius</span><span class="p">,</span><span class="n">fill</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="c1"># the cut (does sum for bkg)</span>
    <span class="n">xy_2</span> <span class="o">=</span> <span class="p">(</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">shift_y</span><span class="p">,</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">shift_y</span><span class="p">)</span> 
    <span class="n">cut_2</span> <span class="o">=</span> <span class="n">Cutout2D</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">data</span><span class="p">,</span><span class="n">xy_2</span><span class="p">,</span><span class="n">equivalent_radius</span><span class="p">)</span>
    
    <span class="n">bkg_core</span><span class="p">,</span><span class="n">bkg_1</span><span class="p">,</span><span class="n">bkg_2</span> <span class="o">=</span> <span class="p">(</span><span class="n">cut_core</span><span class="p">,</span><span class="n">box_core</span><span class="p">),(</span><span class="n">cut_1</span><span class="p">,</span><span class="n">box_1</span><span class="p">),(</span><span class="n">cut_2</span><span class="p">,</span><span class="n">box_2</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">diff</span> <span class="ow">or</span> <span class="n">ref</span><span class="p">:</span>
        <span class="c1"># default diff None and ref None but if provided will return list of cuts order like [source,diff,ref]</span>
        <span class="k">return</span> <span class="n">targ_obj</span><span class="p">,</span><span class="n">cuts</span><span class="p">,</span><span class="n">bkg_core</span><span class="p">,</span><span class="n">bkg_1</span><span class="p">,</span><span class="n">bkg_2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">targ_obj</span><span class="p">,</span><span class="n">cut_targ</span><span class="p">,</span><span class="n">bkg_core</span><span class="p">,</span><span class="n">bkg_1</span><span class="p">,</span><span class="n">bkg_2</span></div>

<div class="viewcode-block" id="plant"><a class="viewcode-back" href="../../api.html#efficiency_pipeline.lco_fakeSNpipeline.plant">[docs]</a><span class="k">def</span> <span class="nf">plant</span><span class="p">(</span><span class="n">image</span><span class="p">,</span><span class="n">psf</span><span class="p">,</span><span class="n">source_cat</span><span class="p">,</span><span class="n">hdr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">mag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">location</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">zp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">plantname</span><span class="o">=</span><span class="s1">&#39;planted.fits&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    helper function for detection efficiency plants SNe (the scaled epsf) into an image to be detected</span>
<span class="sd">    returns the planted image data and creates fits image using plantname arg </span>
<span class="sd">    image argument should be difference fits, i.e. want to detect plants on difference </span>
<span class="sd">    psf argument from epsf fcn</span>
<span class="sd">    source_cat argument from source_cat fcn  </span>
<span class="sd">    zp argument left as None will be determined using hdr vals like zp=skybr+2.5*np.log10(L1med/exptime/pixscale)</span>
<span class="sd">    mag argument scales epsf (the SN) like mu = 10**((mag-zp)/-2.5)*exptime*pixscale   </span>
<span class="sd">    location ~ where will plant is flexible:</span>
<span class="sd">    Skycoord(ra,dec)</span>
<span class="sd">    tuple for grid see lattice helper function </span>
<span class="sd">    list for galaxy-galaxy strong lens target  see target helper function</span>
<span class="sd">    None will use hdr val</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># unpack the source_cat so can use the targ_obj to place SN later if not given a location explicitly</span>
    <span class="n">cat</span><span class="p">,</span><span class="n">orig_image</span><span class="p">,</span><span class="n">threshold</span><span class="p">,</span><span class="n">segm</span><span class="p">,</span><span class="n">targ_obj</span><span class="o">=</span><span class="n">source_cat</span> <span class="c1"># orig_image ~ meaning that pointing which source cat was run on not a diff</span>
    
    <span class="c1"># if image is the diff, (or any of the cutouts) none of these are available, provide it explicitly from source hdr</span>
    <span class="n">skymag</span><span class="o">=</span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;SKYMAG&#39;</span><span class="p">]</span> <span class="c1"># computed [mag/arcsec^2]</span>
    <span class="n">skybr</span><span class="o">=</span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;WMSSKYBR&#39;</span><span class="p">]</span> <span class="c1"># meas</span>
    <span class="n">pixscale</span><span class="o">=</span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;PIXSCALE&#39;</span><span class="p">]</span> <span class="c1"># arcsec/pixel</span>
    <span class="n">mean</span><span class="o">=</span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;L1MEAN&#39;</span><span class="p">]</span> <span class="c1"># sigma-clipped mean bkg [counts]</span>
    <span class="n">med</span><span class="o">=</span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;L1MEDIAN&#39;</span><span class="p">]</span>
    <span class="n">sig</span><span class="o">=</span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;L1SIGMA&#39;</span><span class="p">]</span>
    <span class="n">fwhm</span><span class="o">=</span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;L1FWHM&#39;</span><span class="p">]</span>
    <span class="n">exptime</span><span class="o">=</span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;EXPTIME&#39;</span><span class="p">]</span>

    <span class="c1">#print(&#39;L1: mean,exptime,pixscale,fwhm&#39;,mean,exptime,pixscale,fwhm)</span>
    <span class="c1"># the sigma-clipped stats I think should be same as L1 </span>
    <span class="n">mean_val</span><span class="p">,</span> <span class="n">median_val</span><span class="p">,</span> <span class="n">std_val</span> <span class="o">=</span> <span class="n">sigma_clipped_stats</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">2.</span><span class="p">)</span>  
    <span class="c1">#print(&#39;scs: mean_val,median_val,std_val&#39;,mean_val,median_val,std_val)</span>
    <span class="k">if</span> <span class="n">zp</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
        <span class="c1"># there should be an L1ZP, since there isn&#39;t I&#39;m doing what I think makes sense to calculate it</span>
        <span class="c1"># I know it should be zp ~ 23, so hopefully that is about what we get</span>
        <span class="c1"># /exptime ~ data is in counts but skymag measured seems to be doing count rate, /pixscale since want /arcsec</span>
        <span class="c1"># ... I thought /pixscale^2 was correct but single pixscale is closer to &#39;expected&#39;: https://arxiv.org/pdf/1805.12220.pdf</span>
        <span class="n">zp</span><span class="o">=</span><span class="n">skybr</span><span class="o">+</span><span class="mf">2.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">med</span><span class="o">/</span><span class="n">exptime</span><span class="o">/</span><span class="n">pixscale</span><span class="p">)</span>
        <span class="c1"># these are in the sdss system (r&#39; filter is what is used in our observations) https://www.sdss.org/dr14/algorithms/fluxcal/</span>
        <span class="c1"># effectively same as AB system, u zp is off by .04 mag, z zp might be off by .02 mag but close enough for govt work</span>
    
    <span class="k">if</span> <span class="n">mag</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
        <span class="c1"># if don&#39;t tell it what mag we want SN, I&#39;ll make it 5 mags brighter than bkg sky</span>
        <span class="n">mag</span> <span class="o">=</span> <span class="n">skybr</span><span class="o">-</span><span class="mi">5</span>
    
    <span class="c1"># copying image and psf so can leave original data untouched</span>
    <span class="n">cpim</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="p">((</span><span class="n">mag</span><span class="o">-</span><span class="n">zp</span><span class="p">)</span><span class="o">/-</span><span class="mf">2.5</span><span class="p">)</span><span class="o">*</span><span class="n">exptime</span><span class="o">*</span><span class="n">pixscale</span> <span class="c1"># the factor to multiply psf flux, to achieve given mag </span>
    <span class="c1">#print(&#39;mu &#39;,mu)</span>
    <span class="n">cppsf</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">psf</span><span class="o">.</span><span class="n">data</span><span class="o">*</span><span class="n">mu</span><span class="p">)</span> 
    
    <span class="n">wcs</span><span class="p">,</span><span class="n">frame</span> <span class="o">=</span> <span class="n">WCS</span><span class="p">(</span><span class="n">hdr</span><span class="p">),</span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;RADESYS&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="n">lattice</span><span class="p">,</span><span class="n">boxes</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span><span class="kc">False</span> 
    <span class="k">if</span> <span class="n">location</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
        <span class="c1"># use the targ obj to place SN</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">targ_obj</span><span class="p">[</span><span class="s1">&#39;xcentroid&#39;</span><span class="p">]</span><span class="o">-</span><span class="n">targ_obj</span><span class="p">[</span><span class="s1">&#39;equivalent_radius&#39;</span><span class="p">],</span><span class="n">targ_obj</span><span class="p">[</span><span class="s1">&#39;xcentroid&#39;</span><span class="p">]</span><span class="o">+</span><span class="n">targ_obj</span><span class="p">[</span><span class="s1">&#39;equivalent_radius&#39;</span><span class="p">]]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x</span><span class="p">]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="mi">100</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">targ_obj</span><span class="p">[</span><span class="s1">&#39;ycentroid&#39;</span><span class="p">]</span><span class="o">-</span><span class="n">targ_obj</span><span class="p">[</span><span class="s1">&#39;equivalent_radius&#39;</span><span class="p">],</span><span class="n">targ_obj</span><span class="p">[</span><span class="s1">&#39;ycentroid&#39;</span><span class="p">]</span><span class="o">+</span><span class="n">targ_obj</span><span class="p">[</span><span class="s1">&#39;equivalent_radius&#39;</span><span class="p">]]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">y</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="mi">100</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">pix</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">]</span>
        <span class="n">revpix</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">pix</span><span class="p">)</span>
        <span class="n">revpix</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
        <span class="n">location</span><span class="o">=</span><span class="n">astropy</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">pixel_to_skycoord</span><span class="p">(</span><span class="n">pix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">pix</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">wcs</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">location</span><span class="p">)</span><span class="o">==</span><span class="nb">tuple</span><span class="p">:</span>
        <span class="c1"># lattice was used to generate tuple w lists (skycoords,pixels), we want to plant many SNe across the image</span>
        <span class="n">lattice</span> <span class="o">=</span> <span class="n">location</span>
        <span class="c1"># unpack the lists of lattice</span>
        <span class="n">locations</span><span class="p">,</span><span class="n">pixels</span> <span class="o">=</span> <span class="n">lattice</span>
        <span class="n">lattice</span> <span class="o">=</span> <span class="kc">True</span> 
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">location</span><span class="p">)</span><span class="o">==</span><span class="nb">list</span><span class="p">:</span>
        <span class="c1"># 3 boxes of lxw = req^2, starting ctr on target core and then shifted by req along orientation </span>
        <span class="n">boxes</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># give arb skycoord loc (ra/dec) and translate to pixels for plant</span>
        <span class="n">pix</span><span class="o">=</span><span class="n">astropy</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">skycoord_to_pixel</span><span class="p">(</span><span class="n">location</span><span class="p">,</span><span class="n">wcs</span><span class="p">)</span> <span class="c1"># x,y pixel location</span>
        <span class="n">revpix</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">pix</span><span class="p">))</span> <span class="c1"># row,col location for adding to data... y,x</span>
        <span class="n">revpix</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">boxes</span><span class="p">:</span>
        <span class="c1"># location is list of 3 pixel locations to plant to, one ctr on core of target, 2 more shifted req along orientation of target</span>
        <span class="c1"># the location list is unpacked from target fcn into the pixels in pipeline </span>
        <span class="k">for</span> <span class="n">pix</span> <span class="ow">in</span> <span class="n">location</span><span class="p">:</span>
            <span class="n">pix</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">pix</span><span class="p">)</span>
            <span class="n">revpix</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">pix</span><span class="p">)</span>
            <span class="n">revpix</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="c1"># indexes to add the psf to</span>
            <span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="o">=</span><span class="n">revpix</span>
            <span class="n">nrows</span><span class="p">,</span><span class="n">ncols</span><span class="o">=</span><span class="n">cppsf</span><span class="o">.</span><span class="n">shape</span>
            <span class="c1"># +2 in these to grab a couple more than needed, the correct shapes for broadcasting taken using actual psf.shapes</span>
            <span class="n">rows</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">row</span><span class="o">-</span><span class="n">nrows</span><span class="o">/</span><span class="mi">2</span><span class="p">)),</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">row</span><span class="o">+</span><span class="n">nrows</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> 
            <span class="n">cols</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">col</span><span class="o">-</span><span class="n">ncols</span><span class="o">/</span><span class="mi">2</span><span class="p">)),</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">col</span><span class="o">+</span><span class="n">ncols</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> 
            <span class="n">rows</span> <span class="o">=</span> <span class="n">rows</span><span class="p">[:</span><span class="n">cppsf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="n">cols</span><span class="p">[:</span><span class="n">cppsf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">cpim</span><span class="p">[</span><span class="n">rows</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">cols</span><span class="p">]</span> <span class="o">+=</span> <span class="n">cppsf</span>
            <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">cpim</span><span class="p">)</span>
            
        <span class="c1"># inserting True fakeSN into hdr w the pix location</span>
        <span class="n">cphdr</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">hdr</span><span class="p">)</span>
        <span class="n">cphdr</span><span class="p">[</span><span class="s1">&#39;fakeSN&#39;</span><span class="p">]</span><span class="o">=</span><span class="kc">True</span> 
        <span class="n">cphdr</span><span class="p">[</span><span class="s1">&#39;fakeSN_loc&#39;</span><span class="p">]</span><span class="o">=</span><span class="s1">&#39;boxes&#39;</span> 
        <span class="n">cphdr</span><span class="p">[</span><span class="s1">&#39;NfakeSNe&#39;</span><span class="p">]</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">location</span><span class="p">))</span>
        <span class="n">cphdr</span><span class="p">[</span><span class="s1">&#39;fakeSNmag&#39;</span><span class="p">]</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">mag</span><span class="p">)</span>
        <span class="n">cphdr</span><span class="p">[</span><span class="s1">&#39;fakeZP&#39;</span><span class="p">]</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">zp</span><span class="p">)</span>
        <span class="n">fits</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="n">plantname</span><span class="p">,</span><span class="n">cpim</span><span class="p">,</span><span class="n">cphdr</span><span class="p">,</span><span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> SNe mag ~ </span><span class="si">{}</span><span class="s1"> (epsf*=mu ~ </span><span class="si">{}</span><span class="s1">) planted in boxes by targ; zp ~ </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">location</span><span class="p">),</span><span class="n">mag</span><span class="p">,</span><span class="n">mu</span><span class="p">,</span><span class="n">zp</span><span class="p">))</span>
        <span class="n">plant_im</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">plantname</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  
        <span class="k">return</span> <span class="n">plant_im</span><span class="p">,</span><span class="n">location</span>
    <span class="k">if</span> <span class="n">lattice</span><span class="p">:</span>
        <span class="c1"># many locations to plant to</span>
        <span class="k">for</span> <span class="n">pix</span> <span class="ow">in</span> <span class="n">pixels</span><span class="p">:</span>
            <span class="n">pix</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">pix</span><span class="p">)</span>
            <span class="n">revpix</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">pix</span><span class="p">)</span>
            <span class="n">revpix</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="c1"># indexes to add the psf to</span>
            <span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="o">=</span><span class="n">revpix</span>
            <span class="n">nrows</span><span class="p">,</span><span class="n">ncols</span><span class="o">=</span><span class="n">cppsf</span><span class="o">.</span><span class="n">shape</span>
            <span class="c1"># +2 in these to grab a couple more than needed, the correct shapes for broadcasting taken using actual psf.shapes</span>
            <span class="n">rows</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">row</span><span class="o">-</span><span class="n">nrows</span><span class="o">/</span><span class="mi">2</span><span class="p">)),</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">row</span><span class="o">+</span><span class="n">nrows</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> 
            <span class="n">cols</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">col</span><span class="o">-</span><span class="n">ncols</span><span class="o">/</span><span class="mi">2</span><span class="p">)),</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">col</span><span class="o">+</span><span class="n">ncols</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> 
            <span class="n">rows</span> <span class="o">=</span> <span class="n">rows</span><span class="p">[:</span><span class="n">cppsf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="n">cols</span><span class="p">[:</span><span class="n">cppsf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">cpim</span><span class="p">[</span><span class="n">rows</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">cols</span><span class="p">]</span> <span class="o">+=</span> <span class="n">cppsf</span>
            <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">cpim</span><span class="p">)</span>
            
        <span class="c1"># inserting True fakeSN into hdr w the pix location</span>
        <span class="n">cphdr</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">hdr</span><span class="p">)</span>
        <span class="n">cphdr</span><span class="p">[</span><span class="s1">&#39;fakeSN&#39;</span><span class="p">]</span><span class="o">=</span><span class="kc">True</span> 
        <span class="n">cphdr</span><span class="p">[</span><span class="s1">&#39;fakeSN_loc&#39;</span><span class="p">]</span><span class="o">=</span><span class="s1">&#39;lattice&#39;</span> 
        <span class="n">cphdr</span><span class="p">[</span><span class="s1">&#39;NfakeSNe&#39;</span><span class="p">]</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pixels</span><span class="p">))</span>
        <span class="n">cphdr</span><span class="p">[</span><span class="s1">&#39;fakeSNmag&#39;</span><span class="p">]</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">mag</span><span class="p">)</span>
        <span class="n">cphdr</span><span class="p">[</span><span class="s1">&#39;fakeZP&#39;</span><span class="p">]</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">zp</span><span class="p">)</span>
        <span class="n">fits</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="n">plantname</span><span class="p">,</span><span class="n">cpim</span><span class="p">,</span><span class="n">cphdr</span><span class="p">,</span><span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> SNe mag ~ </span><span class="si">{}</span><span class="s1"> (epsf*=mu ~ </span><span class="si">{}</span><span class="s1">) planted in lattice across image; zp ~ </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pixels</span><span class="p">),</span><span class="n">mag</span><span class="p">,</span><span class="n">mu</span><span class="p">,</span><span class="n">zp</span><span class="p">))</span>
        <span class="n">plant_im</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">plantname</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  
        <span class="k">return</span> <span class="n">plant_im</span><span class="p">,</span><span class="n">pixels</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># single location for plant either using targ obj or provided skycoord</span>
        <span class="c1"># indexes for the lco data file to add the psf to</span>
        <span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="o">=</span><span class="n">revpix</span>
        <span class="n">nrows</span><span class="p">,</span><span class="n">ncols</span><span class="o">=</span><span class="n">cppsf</span><span class="o">.</span><span class="n">shape</span>
        <span class="c1"># +2 in these to grab a couple more than needed, the correct shapes for broadcasting taken using actual psf.shapes</span>
        <span class="n">rows</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">row</span><span class="o">-</span><span class="n">nrows</span><span class="o">/</span><span class="mi">2</span><span class="p">)),</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">row</span><span class="o">+</span><span class="n">nrows</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> 
        <span class="n">cols</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">col</span><span class="o">-</span><span class="n">ncols</span><span class="o">/</span><span class="mi">2</span><span class="p">)),</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">col</span><span class="o">+</span><span class="n">ncols</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> 
        <span class="n">rows</span> <span class="o">=</span> <span class="n">rows</span><span class="p">[:</span><span class="n">cppsf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="n">cols</span><span class="p">[:</span><span class="n">cppsf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">cpim</span><span class="p">[</span><span class="n">rows</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">cols</span><span class="p">]</span> <span class="o">+=</span> <span class="n">cppsf</span>
        <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">cpim</span><span class="p">)</span>
        <span class="c1"># write the image with planted SN added to a new fits file (inserting True fakeSN into hdr)</span>
        <span class="n">cphdr</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">hdr</span><span class="p">)</span>
        <span class="n">cphdr</span><span class="p">[</span><span class="s1">&#39;fakeSN&#39;</span><span class="p">]</span><span class="o">=</span><span class="kc">True</span> 
        <span class="n">cphdr</span><span class="p">[</span><span class="s1">&#39;fakeSN_loc&#39;</span><span class="p">]</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">pix</span><span class="p">)</span>
        <span class="n">plant_im</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="n">plantname</span><span class="p">,</span><span class="n">cpim</span><span class="p">,</span><span class="n">cphdr</span><span class="p">,</span><span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;SN mag ~ </span><span class="si">{}</span><span class="s1"> planted in image w bkg mag ~ </span><span class="si">{}</span><span class="s1"> at </span><span class="si">{}</span><span class="s1"> written to </span><span class="si">{}</span><span class="s1">; zp ~ </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mag</span><span class="p">,</span><span class="n">skybr</span><span class="p">,</span><span class="n">location</span><span class="p">,</span><span class="n">plantname</span><span class="p">,</span><span class="n">zp</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">plant_im</span> </div>

<div class="viewcode-block" id="lattice"><a class="viewcode-back" href="../../api.html#efficiency_pipeline.lco_fakeSNpipeline.lattice">[docs]</a><span class="k">def</span> <span class="nf">lattice</span><span class="p">(</span><span class="n">image</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    grid detection efficiency helper function gives evenly spaced skycoord and pixel locations</span>
<span class="sd">    spacing is 100 pixels, limited to 100 pixels away from edge</span>
<span class="sd">    image argument is the fits file</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">hdr</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">header</span>
    <span class="n">wcs</span><span class="p">,</span><span class="n">frame</span><span class="o">=</span><span class="n">WCS</span><span class="p">(</span><span class="n">hdr</span><span class="p">),</span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;RADESYS&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="c1"># have single 4kx4k chip from wide field instrument</span>
    <span class="n">NX</span> <span class="o">=</span> <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;naxis1&#39;</span><span class="p">]</span>
    <span class="n">NY</span> <span class="o">=</span> <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;naxis2&#39;</span><span class="p">]</span>
    <span class="n">edge</span> <span class="o">=</span> <span class="mi">100</span> <span class="c1"># pixels away from edge</span>
    <span class="n">spacing</span> <span class="o">=</span> <span class="mi">100</span> <span class="c1"># pixels between each location on lattice</span>
    <span class="n">x</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="o">+</span><span class="n">edge</span><span class="p">,</span><span class="n">NX</span><span class="o">-</span><span class="n">edge</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">spacing</span><span class="p">))</span> <span class="c1"># +1 to make inclusive</span>
    <span class="n">y</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="o">+</span><span class="n">edge</span><span class="p">,</span><span class="n">NY</span><span class="o">-</span><span class="n">edge</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">spacing</span><span class="p">))</span>
    <span class="n">pixels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
    <span class="n">locations</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># skycoord locations that I will use to plant SNe across image  </span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pixels</span><span class="p">)):</span>
        <span class="n">pix</span> <span class="o">=</span> <span class="n">pixels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">location</span><span class="o">=</span><span class="n">astropy</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">pixel_to_skycoord</span><span class="p">(</span><span class="n">pix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">pix</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">wcs</span><span class="p">)</span>
        <span class="n">locations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">location</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">locations</span><span class="p">,</span><span class="n">pixels</span></div>

<div class="viewcode-block" id="detection_efficiency"><a class="viewcode-back" href="../../api.html#efficiency_pipeline.lco_fakeSNpipeline.detection_efficiency">[docs]</a><span class="k">def</span> <span class="nf">detection_efficiency</span><span class="p">(</span><span class="n">plant</span><span class="p">,</span><span class="n">cat</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The detection efficiency NSN detected to NSN planted measurement</span>
<span class="sd">    determines true and false detections as SN plant within 5 pixel radius of detected location</span>
<span class="sd">    breaks up true into repeat and single detections i.e. which plants were detected multiple times at slightly different loc</span>
<span class="sd">    plant argument from plant helper function has the image w plants and where they are located  </span>
<span class="sd">    cat argument from source_cat function applied to image w plants i.e. you need to do the detection on plant im</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># provide the plant and detection cat run to find efficiency</span>
    <span class="c1"># unpack the plant (the image and locations)</span>
    <span class="n">plant_im</span><span class="p">,</span><span class="n">pixels</span><span class="o">=</span><span class="n">plant</span> 
    <span class="c1"># unpack the detection catalog objs (cat,image,threshold,segm)</span>
    <span class="n">catalog</span><span class="p">,</span><span class="n">image</span><span class="p">,</span><span class="n">threshold</span><span class="p">,</span><span class="n">segm</span><span class="p">,</span><span class="n">targ_obj</span> <span class="o">=</span> <span class="n">cat</span>

    <span class="n">hdr</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">header</span>
    <span class="n">Nfakes</span><span class="o">=</span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;NfakeSNe&#39;</span><span class="p">]</span>
    <span class="n">magfakes</span><span class="o">=</span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;fakeSNmag&#39;</span><span class="p">]</span>
    <span class="c1">#print(&#39;Nfakes ~ {} (= {} quick sanity check) planted in this image&#39;.format(Nfakes,len(pixels)))</span>
    <span class="c1">#print(&#39;Nsources ~ {} detected in the image&#39;.format(len(catalog)))</span>
    
    <span class="c1"># use locations and a search radius on detections and plant locations to get true positives</span>
    <span class="n">tbl</span> <span class="o">=</span> <span class="n">catalog</span><span class="o">.</span><span class="n">to_table</span><span class="p">()</span>
    <span class="n">tbl_x</span><span class="p">,</span><span class="n">tbl_y</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tbl</span><span class="p">[</span><span class="s1">&#39;xcentroid&#39;</span><span class="p">]],</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tbl</span><span class="p">[</span><span class="s1">&#39;ycentroid&#39;</span><span class="p">]]</span>
    <span class="n">tbl_pixels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">tbl_x</span><span class="p">,</span><span class="n">tbl_y</span><span class="p">))</span>
    <span class="n">tbl</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">Column</span><span class="p">(</span><span class="n">tbl_pixels</span><span class="p">),</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;pix&#39;</span><span class="p">)</span> <span class="c1"># adding this for easier use indexing tbl later</span>
    <span class="n">search</span> <span class="o">=</span> <span class="mi">5</span> <span class="c1"># fwhm*n might be better criteria</span>
    <span class="n">truths</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">pixel</span> <span class="ow">in</span> <span class="n">tbl_pixels</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pixels</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pixel</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">search</span>  <span class="ow">and</span> <span class="n">pixel</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">search</span> <span class="ow">and</span> <span class="n">pixel</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">search</span> <span class="ow">and</span> <span class="n">pixel</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">search</span><span class="p">:</span>
                <span class="n">truths</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span><span class="n">pixel</span><span class="p">])</span>
                <span class="c1">#print(i,pixel)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">continue</span>
    <span class="c1">#print(&#39;{} source detections within search radius criteria&#39;.format(len(truths)))</span>
    <span class="c1"># TODO: get the tbl_pixels which were outside the search radius criteria and return them as false positives</span>
    
    <span class="c1"># break truths into the plant pixels and det src pixel lists; easier to work w</span>
    <span class="n">plant_pixels</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">det_src_pixels</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">truths</span><span class="p">:</span>
        <span class="n">plant_pix</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">det_src_pix</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">plant_pixels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">plant_pix</span><span class="p">)</span>
        <span class="n">det_src_pixels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">det_src_pix</span><span class="p">)</span>
    <span class="c1"># the plant pixels which had multiple sources detected around it</span>
    <span class="n">repeat_plant</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">(</span><span class="n">plant_pixels</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>
    <span class="c1"># the plant pixels which only had one source detected </span>
    <span class="n">single_plant</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">(</span><span class="n">plant_pixels</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">N_plants_detected</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">single_plant</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">repeat_plant</span><span class="p">)</span>
    <span class="c1"># adding nearby_plantpix col to src table; using None if source wasnt within the search radius of plant</span>
    <span class="n">plant_col</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tbl</span><span class="p">:</span>
        <span class="n">tbl_x</span><span class="p">,</span><span class="n">tbl_y</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="s1">&#39;xcentroid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">,</span><span class="n">i</span><span class="p">[</span><span class="s1">&#39;ycentroid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tbl_x</span><span class="p">,</span><span class="n">tbl_y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">det_src_pixels</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">det_src_pixels</span><span class="o">.</span><span class="n">index</span><span class="p">((</span><span class="n">tbl_x</span><span class="p">,</span><span class="n">tbl_y</span><span class="p">))</span>
            <span class="n">plant_col</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">plant_pixels</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plant_col</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">tbl</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">Column</span><span class="p">(</span><span class="n">plant_col</span><span class="p">),</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;nearby_plantpix&#39;</span><span class="p">)</span>
    
    <span class="c1"># index table to grab false source detections</span>
    <span class="n">false_tbl</span> <span class="o">=</span> <span class="n">tbl</span><span class="p">[</span><span class="n">tbl</span><span class="p">[</span><span class="s1">&#39;nearby_plantpix&#39;</span><span class="p">]</span><span class="o">==</span><span class="kc">None</span><span class="p">]</span>
    <span class="n">truth_tbl</span> <span class="o">=</span> <span class="n">tbl</span><span class="p">[</span><span class="n">tbl</span><span class="p">[</span><span class="s1">&#39;nearby_plantpix&#39;</span><span class="p">]</span><span class="o">!=</span><span class="kc">None</span><span class="p">]</span>
    
    <span class="n">single_truth_tbl</span><span class="p">,</span><span class="n">repeat_truth_tbl</span> <span class="o">=</span> <span class="p">[],[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">truth_tbl</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="s1">&#39;nearby_plantpix&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">repeat_plant</span><span class="p">:</span>
            <span class="n">repeat_truth_tbl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">single_truth_tbl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="c1"># should use a check on length rather than try/except below here</span>
    <span class="c1"># try/excepting is to avoid error for empty lists</span>
    <span class="c1"># mainly an issue on repeat truth tbl </span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">single_truth_tbl</span> <span class="o">=</span> <span class="n">vstack</span><span class="p">(</span><span class="n">single_truth_tbl</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">repeat_truth_tbl</span> <span class="o">=</span> <span class="n">vstack</span><span class="p">(</span><span class="n">repeat_truth_tbl</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">pass</span>            
    <span class="c1">#print(&#39;Final: {} planted SNe, {} clean single detections, {} as multi-sources near a plant, {} false detections&#39;.format(Nfakes,len(single_truth_tbl),len(repeat_truth_tbl),len(false_tbl)))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> planted SNe had single clean source detected, </span><span class="si">{}</span><span class="s1"> planted SNe had multiple sources detected nearby, </span><span class="si">{}</span><span class="s1"> false detections&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">single_plant</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">repeat_plant</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">false_tbl</span><span class="p">)))</span>

    <span class="n">efficiency</span> <span class="o">=</span> <span class="n">N_plants_detected</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">pixels</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Detection efficiency (N_plants_detected/N_plants) ~ </span><span class="si">{}</span><span class="s1"> on mag ~ </span><span class="si">{}</span><span class="s1"> SNe&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">efficiency</span><span class="p">,</span><span class="n">magfakes</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">efficiency</span><span class="p">,</span><span class="n">magfakes</span><span class="p">,</span><span class="n">tbl</span><span class="p">,</span><span class="n">single_truth_tbl</span><span class="p">,</span><span class="n">repeat_truth_tbl</span><span class="p">,</span><span class="n">false_tbl</span></div>

<div class="viewcode-block" id="lco_pipe_ex"><a class="viewcode-back" href="../../api.html#efficiency_pipeline.lco_fakeSNpipeline.lco_pipe_ex">[docs]</a><span class="k">def</span> <span class="nf">lco_pipe_ex</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="s1">&#39;lco_pipe_example/sdssj2309-0039&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    test case image going through the pipeline.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">current_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">())</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">current_dir</span><span class="p">,</span><span class="n">path</span><span class="p">)</span>
    <span class="n">my_data</span> <span class="o">=</span> <span class="n">get_data</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="c1"># a table that has the galaxy-galaxy strong lens system: id, magnification, lens_z, source_z, peakIa mag</span>
    <span class="n">glsn</span> <span class="o">=</span> <span class="n">ascii</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span><span class="s1">&#39;peakGLSN.csv&#39;</span><span class="p">))</span>

    <span class="n">source_im</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">path</span><span class="o">+</span><span class="s1">&#39;/source_im/*fits&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">source_output</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span><span class="s1">&#39;source_im/output&#39;</span><span class="p">)</span> <span class="c1"># where will be stick results of pipeline </span>
    <span class="n">filename</span><span class="o">=</span><span class="n">source_im</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">image</span> <span class="o">=</span> <span class="n">my_data</span><span class="p">[</span><span class="n">filename</span><span class="p">]</span>
    <span class="n">diff_image</span> <span class="o">=</span> <span class="n">my_data</span><span class="p">[</span><span class="s1">&#39;d_&#39;</span><span class="o">+</span><span class="n">filename</span><span class="p">]</span>
    <span class="n">ref_image</span> <span class="o">=</span> <span class="n">my_data</span><span class="p">[</span><span class="s1">&#39;ref.fits&#39;</span><span class="p">]</span>
    <span class="n">hdr</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">header</span>
    <span class="n">groupid</span><span class="p">,</span><span class="n">L1fwhm</span><span class="p">,</span><span class="n">pixscale</span><span class="p">,</span><span class="n">skybr</span> <span class="o">=</span> <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;GROUPID&#39;</span><span class="p">],</span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;L1fwhm&#39;</span><span class="p">],</span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;pixscale&#39;</span><span class="p">],</span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;WMSSKYBR&#39;</span><span class="p">]</span> <span class="c1"># pixels, arcsec/pixels,mag/arcsec^2</span>
    <span class="n">med</span><span class="p">,</span><span class="n">exptime</span> <span class="o">=</span> <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;L1MEDIAN&#39;</span><span class="p">],</span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;EXPTIME&#39;</span><span class="p">]</span>
    <span class="n">zp</span><span class="o">=</span><span class="n">skybr</span><span class="o">+</span><span class="mf">2.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">med</span><span class="o">/</span><span class="n">exptime</span><span class="o">/</span><span class="n">pixscale</span><span class="p">)</span>
    <span class="n">glsnID</span> <span class="o">=</span> <span class="n">glsn</span><span class="p">[</span><span class="n">glsn</span><span class="p">[</span><span class="s1">&#39;Source ID&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">groupid</span><span class="p">]</span> <span class="c1"># idx the glsn table using id </span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;filename ~ </span><span class="si">{}</span><span class="s1"> (groupid </span><span class="si">{}</span><span class="s1">) has L1fwhm ~ </span><span class="si">{}</span><span class="s1"> pixels, pixscale ~ </span><span class="si">{}</span><span class="s1"> arcsec/pixel, and skybr </span><span class="si">{}</span><span class="s1"> mag/arcsec^2; zp ~ </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="n">groupid</span><span class="p">,</span><span class="n">L1fwhm</span><span class="p">,</span><span class="n">pixscale</span><span class="p">,</span><span class="n">skybr</span><span class="p">,</span><span class="n">zp</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;glsn ~ </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">glsnID</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="n">pickle_to</span> <span class="o">=</span> <span class="n">source_output</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">filename</span><span class="p">[:</span><span class="o">-</span><span class="mi">5</span><span class="p">]</span> <span class="c1"># -5 get rid of .fits</span>

    <span class="c1"># trying to get pickled looks like fails when try to make html get...</span>
    <span class="c1"># RecursionError: maximum recursion depth exceeded while calling a Python object </span>
    <span class="c1"># source_cat = pickle.load(open(pickle_to+&#39;_source_cat.pkl&#39;,&#39;rb&#39;))</span>
    <span class="c1"># epsf = pickle.load(open(pickle_to+&#39;_epsf.pkl&#39;,&#39;rb&#39;))</span>
    <span class="c1"># do I want to load the pkl for each mag plant with efficiency or do I want to just pickle m50 for the targ and grid and load that</span>

    <span class="c1"># made figures, either figure out how to display a pdf in python or run the lco_figures on stuff</span>
    <span class="n">psf</span> <span class="o">=</span> <span class="n">pickle_to</span><span class="o">+</span><span class="s1">&#39;_psf.pdf&#39;</span>
    <span class="n">stars</span> <span class="o">=</span> <span class="n">pickle_to</span><span class="o">+</span><span class="s1">&#39;_stars.pdf&#39;</span>
    <span class="n">tde</span> <span class="o">=</span> <span class="n">pickle_to</span><span class="o">+</span><span class="s1">&#39;_target_detection_efficiency.pdf&#39;</span>
    <span class="n">gde</span> <span class="o">=</span> <span class="n">pickle_to</span><span class="o">+</span><span class="s1">&#39;_detection_efficiency.pdf&#39;</span>
    <span class="n">plants</span> <span class="o">=</span> <span class="n">pickle_to</span><span class="o">+</span><span class="s1">&#39;_plants.pdf&#39;</span></div>

<div class="viewcode-block" id="lco_pipe"><a class="viewcode-back" href="../../api.html#efficiency_pipeline.lco_fakeSNpipeline.lco_pipe">[docs]</a><span class="k">def</span> <span class="nf">lco_pipe</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">lco_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">date_key</span><span class="o">=</span><span class="s1">&#39;sbatch&#39;</span><span class="p">,</span><span class="n">field_key</span><span class="o">=</span><span class="s1">&#39;sbatch&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    pipeline that applies the epsf measurement, fake SN planting at different mags/locations, and detection efficiency measurement for groups of images.</span>
<span class="sd">    the lco_path arg should be str to dir with the data</span>
<span class="sd">    assumes data is in dirs like xx.xx date directory with field dirs that each has dirs dia_in/out/trim and source_im </span>
<span class="sd">    figures/images will be made and stored in an output dir inside the source_ims</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">data</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># assumes you haven&#39;t provided all of this data needed to run the pipeline</span>

        <span class="c1">#print(sys.argv[0]) # the name of this command script  </span>
        <span class="k">if</span> <span class="n">date_key</span> <span class="o">==</span> <span class="s1">&#39;sbatch&#39;</span><span class="p">:</span>
            <span class="n">date_key</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># first sbatch arg is to get xx.xx date</span>
        <span class="k">if</span> <span class="n">field_key</span> <span class="o">==</span> <span class="s1">&#39;sbatch&#39;</span><span class="p">:</span>
            <span class="n">field_key</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="c1"># slurm array idx in sbatch that is of length of the number of fields for date </span>
        <span class="c1"># lco_path ~ current working dir with scripts and sub-dirs of data  </span>
        <span class="k">if</span> <span class="n">lco_path</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lco_path</span> <span class="o">=</span> <span class="s1">&#39;/work/oconnorf/efficiency_pipeline/lco/&#39;</span>
        <span class="c1"># all the dates w lco data in the lco_path </span>
        <span class="n">all_dates</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">lco_path</span><span class="o">+</span><span class="s1">&#39;/*&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
        <span class="c1"># your batch should have xx.xx date given so script knows which set of fields you want to do </span>
        <span class="n">date_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lco_path</span><span class="p">,</span><span class="n">date_key</span><span class="o">+</span><span class="s1">&#39;/*&#39;</span><span class="p">)</span>
        <span class="n">all_fields</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">date_path</span><span class="p">)</span> <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
        <span class="n">field</span> <span class="o">=</span> <span class="n">all_fields</span><span class="p">[</span><span class="n">field_key</span><span class="p">]</span>
        <span class="c1"># which date folder are we in and which field was this slurm idx job </span>

        <span class="c1"># all the fits images needed, the trims, diffs, and ref </span>
        <span class="n">my_data</span> <span class="o">=</span> <span class="n">get_data</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>
        <span class="c1"># a table that has the galaxy-galaxy strong lens system: id, magnification, lens_z, source_z, peakIa mag</span>
        <span class="n">glsn</span> <span class="o">=</span> <span class="n">ascii</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lco_path</span><span class="p">,</span><span class="s1">&#39;peakGLSN.csv&#39;</span><span class="p">))</span>

        <span class="c1"># each field should have a folder source_im (along w dia_out and dia_trim) </span>
        <span class="c1"># in source_im is the image you want to do this for</span>
        <span class="c1"># ie the one that psf is measured on trim and SNe planted to diff of</span>
        <span class="n">source_im</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">field</span><span class="o">+</span><span class="s1">&#39;/source_im/*fits&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">source_output</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">field</span><span class="p">,</span><span class="s1">&#39;source_im/output&#39;</span><span class="p">)</span> <span class="c1"># where will be stick results of pipeline </span>
        <span class="n">filename</span><span class="o">=</span><span class="n">source_im</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">my_data</span><span class="p">[</span><span class="n">filename</span><span class="p">]</span>
        <span class="n">diff_image</span> <span class="o">=</span> <span class="n">my_data</span><span class="p">[</span><span class="s1">&#39;d_&#39;</span><span class="o">+</span><span class="n">filename</span><span class="p">]</span>
        <span class="n">ref_image</span> <span class="o">=</span> <span class="n">my_data</span><span class="p">[</span><span class="s1">&#39;ref.fits&#39;</span><span class="p">]</span>
        <span class="n">hdr</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">header</span>
        <span class="n">groupid</span><span class="p">,</span><span class="n">L1fwhm</span><span class="p">,</span><span class="n">pixscale</span><span class="p">,</span><span class="n">skybr</span> <span class="o">=</span> <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;GROUPID&#39;</span><span class="p">],</span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;L1fwhm&#39;</span><span class="p">],</span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;pixscale&#39;</span><span class="p">],</span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;WMSSKYBR&#39;</span><span class="p">]</span> <span class="c1"># pixels, arcsec/pixels,mag/arcsec^2</span>
        <span class="n">med</span><span class="p">,</span><span class="n">exptime</span> <span class="o">=</span> <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;L1MEDIAN&#39;</span><span class="p">],</span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;EXPTIME&#39;</span><span class="p">]</span>
        <span class="n">zp</span><span class="o">=</span><span class="n">skybr</span><span class="o">+</span><span class="mf">2.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">med</span><span class="o">/</span><span class="n">exptime</span><span class="o">/</span><span class="n">pixscale</span><span class="p">)</span>
        <span class="n">glsnID</span> <span class="o">=</span> <span class="n">glsn</span><span class="p">[</span><span class="n">glsn</span><span class="p">[</span><span class="s1">&#39;Source ID&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">groupid</span><span class="p">]</span> <span class="c1"># idx the glsn table using id </span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;filename ~ </span><span class="si">{}</span><span class="s1"> (groupid </span><span class="si">{}</span><span class="s1">) has L1fwhm ~ </span><span class="si">{}</span><span class="s1"> pixels, pixscale ~ </span><span class="si">{}</span><span class="s1"> arcsec/pixel, and skybr </span><span class="si">{}</span><span class="s1"> mag/arcsec^2; zp ~ </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="n">groupid</span><span class="p">,</span><span class="n">L1fwhm</span><span class="p">,</span><span class="n">pixscale</span><span class="p">,</span><span class="n">skybr</span><span class="p">,</span><span class="n">zp</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;glsn ~ </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">glsnID</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="n">pickle_to</span> <span class="o">=</span> <span class="n">source_output</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">filename</span><span class="p">[:</span><span class="o">-</span><span class="mi">5</span><span class="p">]</span> <span class="c1"># -5 get rid of .fits</span>
    
    <span class="c1"># photutils source properties to detect objs in image</span>
    <span class="n">nsigma</span><span class="p">,</span><span class="n">kernel_size</span><span class="p">,</span><span class="n">npixels</span><span class="p">,</span><span class="n">deblend</span><span class="p">,</span><span class="n">contrast</span><span class="p">,</span><span class="n">targ_coord</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">L1fwhm</span><span class="o">/</span><span class="n">pixscale</span><span class="p">)),</span><span class="kc">False</span><span class="p">,</span><span class="o">.</span><span class="mi">001</span><span class="p">,</span><span class="kc">None</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Source Catalog is a photutils source_properties using nsigma ~ </span><span class="si">{}</span><span class="s1"> (detection threshold above img bkg), gaussian kernel sized ~ </span><span class="si">{}</span><span class="s1"> pix, npixels ~ </span><span class="si">{}</span><span class="s1"> (connected pixels needed to be considered source), deblend ~ </span><span class="si">{}</span><span class="s1"> w contrast </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nsigma</span><span class="p">,</span><span class="n">kernel_size</span><span class="p">,</span><span class="n">npixels</span><span class="p">,</span><span class="n">deblend</span><span class="p">,</span><span class="n">contrast</span><span class="p">))</span>
    <span class="n">source_catalog</span> <span class="o">=</span> <span class="n">source_cat</span><span class="p">(</span><span class="n">image</span><span class="p">,</span><span class="n">nsigma</span><span class="o">=</span><span class="n">nsigma</span><span class="p">,</span><span class="n">kernel_size</span><span class="o">=</span><span class="n">kernel_size</span><span class="p">,</span><span class="n">npixels</span><span class="o">=</span><span class="n">npixels</span><span class="p">,</span><span class="n">deblend</span><span class="o">=</span><span class="n">deblend</span><span class="p">,</span><span class="n">contrast</span><span class="o">=</span><span class="n">contrast</span><span class="p">,</span><span class="n">targ_coord</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">cat</span><span class="p">,</span><span class="n">image</span><span class="p">,</span><span class="n">threshold</span><span class="p">,</span><span class="n">segm</span><span class="p">,</span><span class="n">targ_obj</span> <span class="o">=</span> <span class="n">source_catalog</span> <span class="c1"># unpacked to make a little clearer</span>
    <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">cat</span><span class="p">,</span><span class="nb">open</span><span class="p">(</span><span class="n">pickle_to</span> <span class="o">+</span> <span class="s1">&#39;_source_cat.pkl&#39;</span><span class="p">,</span><span class="s1">&#39;wb&#39;</span><span class="p">))</span>

    <span class="c1"># get stars from the astroquery on gaia</span>
    <span class="n">results</span> <span class="o">=</span> <span class="n">gaia_results</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
    <span class="n">gaia</span><span class="p">,</span><span class="n">image</span> <span class="o">=</span> <span class="n">results</span> <span class="c1"># unpacked </span>
    <span class="c1"># extract good gaia stars from image for psf</span>
    <span class="n">extracted_stars</span> <span class="o">=</span> <span class="n">stars</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
    <span class="n">good_stars</span><span class="p">,</span><span class="n">image</span> <span class="o">=</span> <span class="n">extracted_stars</span> <span class="c1"># unpacked</span>
    <span class="c1"># use extracted stars to build epsf</span>
    <span class="n">EPSF</span> <span class="o">=</span> <span class="n">ePSF</span><span class="p">(</span><span class="n">extracted_stars</span><span class="p">,</span><span class="n">oversampling</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">epsf</span><span class="p">,</span><span class="n">fitted_stars</span> <span class="o">=</span> <span class="n">EPSF</span> <span class="c1"># unpacked</span>
    <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">EPSF</span><span class="p">,</span><span class="nb">open</span><span class="p">(</span><span class="n">pickle_to</span><span class="o">+</span><span class="s1">&#39;_epsf.pkl&#39;</span><span class="p">,</span><span class="s1">&#39;wb&#39;</span><span class="p">))</span>
    <span class="c1"># fit 2d gaussian to the epsf, see how &#39;non-gaussian&#39; the actual psf is</span>
    <span class="n">epsf_gaussian</span> <span class="o">=</span> <span class="n">gaussian2d</span><span class="p">(</span><span class="n">epsf</span><span class="p">)</span>
    <span class="n">fit_gaussian</span><span class="p">,</span><span class="n">levels</span><span class="p">,</span><span class="n">xctr_vals</span><span class="p">,</span><span class="n">yctr_vals</span><span class="p">,</span><span class="n">image1</span><span class="p">,</span><span class="n">img_epsf</span><span class="p">,</span><span class="n">resid</span> <span class="o">=</span> <span class="n">epsf_gaussian</span> <span class="c1"># unpacked... levels list amplitude - sigma, ctr vals are gauss model sliced, image1 is array of values from gaussian fit in shape of epsf, img_epsf is epsf instance of it, resid is gauss - epsf </span>
    <span class="c1"># make figures</span>
    <span class="n">psf_and_gauss</span><span class="p">(</span><span class="n">epsf</span><span class="p">,</span><span class="n">epsf_gaussian</span><span class="p">,</span><span class="n">saveas</span><span class="o">=</span><span class="n">pickle_to</span><span class="o">+</span><span class="s1">&#39;_psf.pdf&#39;</span><span class="p">)</span>
    <span class="n">used_stars</span><span class="p">(</span><span class="n">fitted_stars</span><span class="p">,</span><span class="n">saveas</span><span class="o">=</span><span class="n">pickle_to</span><span class="o">+</span><span class="s1">&#39;_stars.pdf&#39;</span><span class="p">)</span>

    <span class="c1"># target galaxy work, tuples cutting boxes around target (data,patch), how/if planting on cores might lower detection efficiency</span>
    <span class="c1"># also returns targ_obj again account for updates using ref (in the cases where empty targ_obj ie not detected in source)</span>
    <span class="n">target_boxes</span> <span class="o">=</span> <span class="n">target</span><span class="p">(</span><span class="n">image</span><span class="p">,</span><span class="n">targ_obj</span><span class="p">,</span><span class="n">ref</span><span class="o">=</span><span class="n">ref_image</span><span class="p">,</span><span class="n">diff</span><span class="o">=</span><span class="n">diff_image</span><span class="p">)</span> 
    <span class="n">targ_obj</span><span class="p">,</span><span class="n">cuts</span><span class="p">,</span><span class="n">bkg_core</span><span class="p">,</span><span class="n">bkg_1</span><span class="p">,</span><span class="n">bkg_2</span> <span class="o">=</span> <span class="n">target_boxes</span> <span class="c1"># unpacked</span>
    <span class="n">cut_targ</span><span class="p">,</span><span class="n">cut_diff</span><span class="p">,</span><span class="n">cut_ref</span> <span class="o">=</span> <span class="n">cuts</span> <span class="c1"># unpack cuts around target source,diff,and ref</span>

    <span class="c1"># measured psf is now going to be scaled to different magnitudes and planted in the difference image</span>
    <span class="n">mags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">skybr</span><span class="o">-</span><span class="mf">4.5</span><span class="p">,</span><span class="n">skybr</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span><span class="mf">0.5</span><span class="p">)</span> <span class="c1">#zp ~ 23.5 # rough zp </span>

    <span class="c1"># this loop (repeatedly) plants near target galaxy; repeated so efficiency can be determined</span>
    <span class="c1"># the box plant wants a list of pixel coordinates, accessing from the target boxes here</span>
    <span class="n">target_locations_orig</span> <span class="o">=</span> <span class="p">[</span><span class="n">bkg_core</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">center_original</span><span class="p">,</span><span class="n">bkg_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">center_original</span><span class="p">,</span><span class="n">bkg_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">center_original</span><span class="p">]</span> <span class="c1"># [0] so cut not patch</span>
    <span class="n">target_locations_cutout</span> <span class="o">=</span> <span class="p">[</span><span class="n">bkg_core</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">center_cutout</span><span class="p">,</span><span class="n">bkg_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">center_cutout</span><span class="p">,</span><span class="n">bkg_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">center_cutout</span><span class="p">]</span>
    <span class="c1"># planting on target centroid at many magnitudes, I am not using the two shifts really only interested to see core</span>
    <span class="c1"># running detection repeatedly to determine efficiency</span>
    <span class="n">efficiencies</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">mag</span> <span class="ow">in</span> <span class="n">mags</span><span class="p">:</span>
        <span class="n">efficiencies</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        <span class="c1"># planting into difference image</span>
        <span class="n">box_plantname</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_planted_targ_mag</span><span class="si">{}</span><span class="s1">.fits&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pickle_to</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="n">mag</span><span class="p">))</span>
        <span class="n">box_planted_orig</span> <span class="o">=</span> <span class="n">plant</span><span class="p">(</span><span class="n">diff_image</span><span class="p">,</span><span class="n">epsf</span><span class="p">,</span><span class="n">source_catalog</span><span class="p">,</span><span class="n">hdr</span><span class="o">=</span><span class="n">hdr</span><span class="p">,</span><span class="n">mag</span><span class="o">=</span><span class="n">mag</span><span class="p">,</span><span class="n">location</span><span class="o">=</span><span class="p">[</span><span class="n">target_locations_orig</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span><span class="n">zp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">plantname</span><span class="o">=</span><span class="n">box_plantname</span><span class="p">)</span>
        <span class="c1"># unpack</span>
        <span class="n">box_plant_im</span><span class="p">,</span><span class="n">box_pixels</span> <span class="o">=</span> <span class="n">box_planted_orig</span> 
        <span class="c1"># make target figures (similar to prev w source but now diff and plants)</span>
        <span class="c1">#target_image(box_plant_im,targ,saveas=pickle_to+&#39;_target_plantdiff_mag{}.pdf&#39;.format(str(mag)))</span>
        <span class="c1"># get a pdf showing image,ref,diff,fakeplant for SN w this mag</span>
        <span class="n">view_targetplant</span><span class="p">(</span><span class="n">image</span><span class="p">,</span><span class="n">ref_image</span><span class="p">,</span><span class="n">diff_image</span><span class="p">,</span><span class="n">box_plant_im</span><span class="p">,</span><span class="n">target_boxes</span><span class="p">,</span><span class="n">zp</span><span class="p">,</span><span class="n">saveas</span><span class="o">=</span><span class="n">pickle_to</span><span class="o">+</span><span class="s1">&#39;targetplant_mag</span><span class="si">{}</span><span class="s1">.pdf&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">mag</span><span class="p">)))</span>

        <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># The detection either works or doesn&#39;t for a plant there is no randomness in algorithm </span>
        <span class="c1"># i.e. the catalog returned for an image is the same for a given detection</span>
        <span class="c1"># Therefor don&#39;t really need to do detection in range(0,N) but I do it twice anyways</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
            <span class="c1"># source properties of detected objs in fake image</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
            <span class="n">fakesource_cat</span> <span class="o">=</span> <span class="n">source_cat</span><span class="p">(</span><span class="n">box_plant_im</span><span class="p">,</span><span class="n">nsigma</span><span class="o">=</span><span class="n">nsigma</span><span class="p">,</span><span class="n">kernel_size</span><span class="o">=</span><span class="n">kernel_size</span><span class="p">,</span><span class="n">npixels</span><span class="o">=</span><span class="n">npixels</span><span class="p">,</span><span class="n">deblend</span><span class="o">=</span><span class="n">deblend</span><span class="p">,</span><span class="n">contrast</span><span class="o">=</span><span class="n">contrast</span><span class="p">,</span><span class="n">targ_coord</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">fakecat</span><span class="p">,</span><span class="n">fakeimage</span><span class="p">,</span><span class="n">fakethreshold</span><span class="p">,</span><span class="n">fakesegm</span><span class="p">,</span><span class="n">faketarg_obj</span> <span class="o">=</span> <span class="n">fakesource_cat</span> <span class="c1"># unpacked to make a little clearer</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">fakecat</span><span class="p">,</span><span class="nb">open</span><span class="p">(</span><span class="n">pickle_to</span><span class="o">+</span><span class="s1">&#39;_fakesource_cat</span><span class="si">{}</span><span class="s1">.pkl&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)),</span><span class="s1">&#39;wb&#39;</span><span class="p">))</span>

            <span class="c1"># detection efficiency  </span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">detection_efficiency</span><span class="p">(</span><span class="n">box_planted_orig</span><span class="p">,</span><span class="n">fakesource_cat</span><span class="p">)</span>
            <span class="n">efficiency</span><span class="p">,</span><span class="n">magfakes</span><span class="p">,</span><span class="n">tbl</span><span class="p">,</span><span class="n">single_truth_tbl</span><span class="p">,</span><span class="n">repeat_truth_tbl</span><span class="p">,</span><span class="n">false_tbl</span> <span class="o">=</span> <span class="n">tmp</span>
            <span class="n">efficiencies</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">efficiency</span><span class="p">)</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span><span class="nb">open</span><span class="p">(</span><span class="n">pickle_to</span><span class="o">+</span><span class="s1">&#39;_detection_efficiency</span><span class="si">{}</span><span class="s1">_mag</span><span class="si">{}</span><span class="s1">.pkl&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="nb">str</span><span class="p">(</span><span class="n">mag</span><span class="p">)),</span><span class="s1">&#39;wb&#39;</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">efficiency</span><span class="p">,</span><span class="n">magfakes</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;--------------------------------------------------------------&#39;</span><span class="p">)</span>
    <span class="n">avg_efficiencies</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">efficiencies</span><span class="p">:</span>
        <span class="n">efficiency</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">efficiency</span><span class="p">)</span>
        <span class="n">avg_efficiencies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">efficiency</span><span class="p">)</span>
    <span class="n">avg_efficiencies</span><span class="p">,</span><span class="n">mags</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">avg_efficiencies</span><span class="p">),</span><span class="nb">list</span><span class="p">(</span><span class="n">mags</span><span class="p">)</span>
    <span class="n">avg_efficiencies</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
    <span class="n">mags</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
    <span class="n">m50</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span><span class="n">avg_efficiencies</span><span class="p">,</span><span class="n">mags</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;m50 ~ </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">m50</span><span class="p">))</span>  
    <span class="c1"># make figures</span>
    <span class="n">detection_efficiency</span><span class="p">(</span><span class="n">mags</span><span class="p">,</span><span class="n">avg_efficiencies</span><span class="p">,</span><span class="n">m50</span><span class="p">,</span><span class="n">target_boxes</span><span class="p">,</span><span class="n">skybr</span><span class="p">,</span><span class="n">zp</span><span class="p">,</span><span class="n">glsn</span><span class="o">=</span><span class="n">glsnID</span><span class="p">,</span><span class="n">saveas</span><span class="o">=</span><span class="n">pickle_to</span><span class="o">+</span><span class="s1">&#39;_target_detection_efficiency.pdf&#39;</span><span class="p">)</span>

    <span class="c1"># lattice plant into the difference, a second way to do detection efficiency</span>
    <span class="n">mags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">skybr</span><span class="o">-</span><span class="mf">4.5</span><span class="p">,</span><span class="n">skybr</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span><span class="mf">0.5</span><span class="p">)</span> <span class="c1"># get mags back in order, zp ~ 23.5 # rough zp </span>
    <span class="n">locations</span> <span class="o">=</span> <span class="n">lattice</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
    <span class="n">efficiencies</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">mag</span> <span class="ow">in</span> <span class="n">mags</span><span class="p">:</span>
        <span class="c1"># create plant image; zp None, using measure sky mag/arcsec^2 from L1 hdr to set</span>
        <span class="n">plantname</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_planted_lattice_mag</span><span class="si">{}</span><span class="s1">.fits&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pickle_to</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="n">mag</span><span class="p">))</span>
        <span class="n">planted</span> <span class="o">=</span> <span class="n">plant</span><span class="p">(</span><span class="n">diff_image</span><span class="p">,</span><span class="n">epsf</span><span class="p">,</span><span class="n">source_catalog</span><span class="p">,</span><span class="n">hdr</span><span class="o">=</span><span class="n">hdr</span><span class="p">,</span><span class="n">mag</span><span class="o">=</span><span class="n">mag</span><span class="p">,</span><span class="n">location</span><span class="o">=</span><span class="n">locations</span><span class="p">,</span><span class="n">zp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">plantname</span><span class="o">=</span><span class="n">plantname</span><span class="p">)</span>
        <span class="n">plant_im</span><span class="p">,</span><span class="n">pixels</span> <span class="o">=</span> <span class="n">planted</span> <span class="c1"># unpack</span>

        <span class="c1"># source properties of detected objs in fake image</span>
        <span class="n">fakesource_cat</span> <span class="o">=</span> <span class="n">source_cat</span><span class="p">(</span><span class="n">plant_im</span><span class="p">,</span><span class="n">nsigma</span><span class="o">=</span><span class="n">nsigma</span><span class="p">,</span><span class="n">kernel_size</span><span class="o">=</span><span class="n">kernel_size</span><span class="p">,</span><span class="n">npixels</span><span class="o">=</span><span class="n">npixels</span><span class="p">,</span><span class="n">deblend</span><span class="o">=</span><span class="n">deblend</span><span class="p">,</span><span class="n">contrast</span><span class="o">=</span><span class="n">contrast</span><span class="p">,</span><span class="n">targ_coord</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">fakecat</span><span class="p">,</span><span class="n">fakeimage</span><span class="p">,</span><span class="n">fakethreshold</span><span class="p">,</span><span class="n">fakesegm</span><span class="p">,</span><span class="n">faketarg_obj</span> <span class="o">=</span> <span class="n">fakesource_cat</span> <span class="c1"># unpacked to make a little clearer</span>
        <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">fakecat</span><span class="p">,</span><span class="nb">open</span><span class="p">(</span><span class="n">pickle_to</span><span class="o">+</span><span class="s1">&#39;_fakesource_cat.pkl&#39;</span><span class="p">,</span><span class="s1">&#39;wb&#39;</span><span class="p">))</span>

        <span class="c1"># detection efficiency  </span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">detection_efficiency</span><span class="p">(</span><span class="n">planted</span><span class="p">,</span><span class="n">fakesource_cat</span><span class="p">)</span>
        <span class="n">efficiency</span><span class="p">,</span><span class="n">magfakes</span><span class="p">,</span><span class="n">tbl</span><span class="p">,</span><span class="n">single_truth_tbl</span><span class="p">,</span><span class="n">repeat_truth_tbl</span><span class="p">,</span><span class="n">false_tbl</span> <span class="o">=</span> <span class="n">tmp</span>
        <span class="n">efficiencies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">efficiency</span><span class="p">)</span>
        <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span><span class="nb">open</span><span class="p">(</span><span class="n">pickle_to</span><span class="o">+</span><span class="s1">&#39;_detection_efficiency_mag</span><span class="si">{}</span><span class="s1">.pkl&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">mag</span><span class="p">)),</span><span class="s1">&#39;wb&#39;</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">efficiency</span><span class="p">,</span><span class="n">magfakes</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;--------------------------------------------------------------&#39;</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;efficiencies: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">efficiencies</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;mags: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mags</span><span class="p">))</span>
    <span class="c1"># use interp to get magnitude at which we have 50% detection efficiency </span>
    <span class="c1"># need the values increasing along x for interp to work properly</span>
    <span class="n">efficiencies</span><span class="p">,</span><span class="n">mags</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">efficiencies</span><span class="p">),</span><span class="nb">list</span><span class="p">(</span><span class="n">mags</span><span class="p">)</span>
    <span class="n">efficiencies</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
    <span class="n">mags</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
    <span class="n">m50</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span><span class="n">efficiencies</span><span class="p">,</span><span class="n">mags</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;m50 ~ </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">m50</span><span class="p">))</span>

    <span class="c1"># make figures</span>
    <span class="n">detection_efficiency</span><span class="p">(</span><span class="n">mags</span><span class="p">,</span><span class="n">efficiencies</span><span class="p">,</span><span class="n">m50</span><span class="p">,</span><span class="n">target_boxes</span><span class="p">,</span><span class="n">skybr</span><span class="p">,</span><span class="n">zp</span><span class="p">,</span><span class="n">glsn</span><span class="o">=</span><span class="n">glsnID</span><span class="p">,</span><span class="n">saveas</span><span class="o">=</span><span class="n">pickle_to</span><span class="o">+</span><span class="s1">&#39;_detection_efficiency.pdf&#39;</span><span class="p">)</span>
    <span class="n">lattice_planted</span><span class="p">(</span><span class="n">mags</span><span class="p">,</span><span class="n">m50</span><span class="p">,</span><span class="n">pickle_to</span><span class="o">=</span><span class="n">pickle_to</span><span class="p">,</span><span class="n">saveas</span><span class="o">=</span><span class="n">pickle_to</span><span class="o">+</span><span class="s1">&#39;_plants.pdf&#39;</span><span class="p">)</span></div>

<span class="k">if</span> <span class="vm">__name__</span><span class="o">==</span><span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="c1">#print(&#39;lco pipe coming at ya&#39;)</span>
    <span class="n">lco_pipe</span><span class="p">()</span>

</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020 Kyle OConnor

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>